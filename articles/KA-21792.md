---
title: "Änderungen bei der Handhabung von Nullwerten in GraphQL | AEM"
description: Beschreibung
solution: Experience Manager as a Cloud Service
product: Experience Manager as a Cloud Service
applies-to: "Experience Manager as a Cloud Service"
keywords: "KCS, Adobe Experience Manager, GraphQL"
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Victoria Barnato
article-created-date: "4/27/2023 7:07:50 PM"
article-published-by: Victoria Barnato
article-published-date: "4/27/2023 7:10:18 PM"
version-number: 6
article-number: KA-21792
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=a1795fca-2ee5-ed11-a7c7-6045bd0061cb"
source-git-commit: 49456a4e39cbbdc507448cf6e6ceb9a2eb1853be
workflow-type: tm+mt
source-wordcount: '692'
ht-degree: 1%

---

# Änderungen bei der Handhabung von Nullwerten in GraphQL | AEM

## Beschreibung {#description}

<b>Umgebung</b><br><br>Experience Manager as a Cloud Service<br><br><br><br><b>Problem/Symptome</b><br><br>In der Version 2023.02.11382 wurden einige Verbesserungen am <b>GraphQL</b> Implementierung (Open Source Query Language), die zu unerwartetem Verhalten im Anwendungs-Code führen kann, falls er sich auf das fehlerhafte Verhalten älterer Versionen stützt. 
<br>Die unten aufgeführte Lösung hilft zu erreichen, dass Adobe Experience Manager (AEM GraphQL) jetzt Inhalte mit *null* -Werte bei allen Filtervorgängen konsistent sind. <br>

## Auflösung {#resolution}

<b>`CONTAINS_NOT` und *null* values</b><br> <br>Die erste Änderung wirkt sich auf Filterbedingungen aus, die die `CONTAINS_NOT` Operator. In früheren Versionen wurde dies `CONTAINS_NOT` keine Inhaltsfragmente zurückgegeben, die *null* -Werte in dem Feld, auf das die Filterbedingung angewendet wurde. Dies widerspricht ähnlichen Operatoren wie `EQUALS_NOT` oder `NOT_AT`.<br>Stellen Sie sicher, dass Ihre Client-Anwendung *null* Werte, die von AEM bei Verwendung von `CONTAINS_NOT`.<br> <br><b>Beispiel:</b>

| <b>Fragment filtern</b> | <b>Daten</b> | <b>Ergebnis vor 2023.02.11382</b> | <b>Ergebnis ab 2023.02.11382</b> |
| --- | --- | --- | --- |
| myField: {<br>    Wert: &quot;frag&quot;, <br>    _op: CONTAINS_NOT<br>} | <br>    {<br>        myField: null<br>    }, <br>    {<br>        myField: &quot;Beliebiger Text&quot;<br>    },<br>    {<br>        myField: &quot;Textfragment&quot;<br>    }<br> | <br>    {<br>        myField: &quot;Beliebiger Text&quot;<br>    }<br> | <br>    {<br>        myField: null<br>    },<br>    {<br>        myField: &quot;Beliebiger Text&quot;<br>    }<br> |

<b>Anwenden von Modi `ALL_OR_EMPTY/ALL` und *null* values</b>
Ein weiteres Problem, das 2023.02.11382 behoben wurde, bezieht sich auf *null* Werte in Filterbedingungen für Felder mit mehreren Werten. Anwenden-Modus `ALL_OR_EMPTY` (bei Arrays/Feldern mit mehreren Werten) keine Fragmente mit *null* -Werte für das betreffende Feld verwenden, funktionierte es also tatsächlich so, wie Sie es für die `ALL` -Methode anwenden. Gleichzeitig filtern Sie ein Feld mit mehreren Werten mit dem Anwendungsmodus `ALL` würde Fragmente mit leerem Inhalt für dieses Feld einschließen, dies sollte jedoch nicht der Fall sein. Es wird empfohlen, die Abfragen zu testen, die einen dieser Anwendungsmodi verwenden, und sie zu ändern, wenn sie nicht mehr das erwartete Ergebnis aus 2023.02.11382 zurückgeben.

Beachten Sie, dass das Problem nur bei einigen Benutzern bestand (vor 2023.02.11382).
Beispiel: `EQUALS_NOT` wie erwartet bei der angewandten Methode `ALL_OR_EMPTY`in der Erwägung, dass `CONTAINS` nicht.
<b>Beispiel:</b>

| <b>Fragment filtern</b> | <b>Daten</b> | <b>Ergebnis vor 2023.02.11382</b> | <b>Ergebnis ab 2023.02.11382</b> |
| --- | --- | --- | --- |
| myArray: {<br>  _ausdrücke: {<br>    Wert: &quot;1.3&quot;<br>    _operator: EQUALS_NOT<br>    _apply: ALL<br>  }<br>} | <br>  {<br>    myArray: null<br>  },<br>  {<br>    myArray: &quot;1.1&quot;, &quot;1.2&quot;, &quot;1.3&quot; <br>  },<br>  {<br>    myArray: &quot;2.1&quot;, &quot;2.2&quot;, &quot;2.3&quot; <br>  }<br> | <br>  {<br>    myArray: null<br>  },<br>  {<br>    myArray: &quot;2.1&quot;, &quot;2.2&quot;, &quot;2.3&quot; <br>  }<br> | <br>  {<br>    myArray: &quot;2.1&quot;, &quot;2.2&quot;, &quot;2.3&quot; <br>  }<br> |
| myArray: {<br>  _ausdrücke: {<br>    Wert: &quot;2.&quot;<br>    _operator: ENTHÄLT<br>    _apply: ALL_OR_EMPTY<br>  }<br>} | <br>  {<br>    myArray: &quot;2.1&quot;, &quot;2.2&quot;, &quot;2.3&quot; <br>  }<br> | <br>  {<br>    myArray: null<br>  },<br>  {<br>    myArray: &quot;2.1&quot;, &quot;2.2&quot;, &quot;2.3&quot; <br>  }<br> |

<b>Anwenden von Modi: `INSTANCES`, `_instances: 0` und *null* values</b>
Das letzte Problem betrifft auch *null* Werte in Filterbedingungen für Felder mit mehreren Werten. Anwenden-Modus `INSTANCES` mit`_instances: 0` nicht mit den Inhaltsfragmenten übereinstimmen, die *null* -Werte in dem entsprechenden Feld vor 2023.02.11382, beginnt jedoch mit 2023.02.11382. Es wird empfohlen, die Abfragen zu testen, die diese Konstellation verwenden, und sie zu ändern, wenn sie nicht das erwartete Ergebnis von 2023.02.113 zurückgeben. 82.
<b>Beispiel:</b>

| <b>Fragment filtern</b> | <b>Daten</b> | <b>Ergebnis vor 2023.02.11382</b> | <b>Ergebnis ab 2023.02.11382</b> |
| --- | --- | --- | --- |
| myArray: {<br>  _ausdrücke: {<br>    Wert: &quot;2.&quot;<br>    _operator: ENTHÄLT<br>    _apply: INSTANZEN<br>    _instances: 0<br>  }<br>} | <br>  {<br>    myArray: null<br>  },<br>  {<br>    myArray: &quot;1.1&quot;, &quot;1.2&quot;, &quot;1.3&quot; <br>  },<br>  {<br>    myArray: &quot;2.1&quot;, &quot;2.2&quot;, &quot;2.3&quot; <br>  }<br> | <br>  {<br>    myArray: &quot;1.1&quot;, &quot;1.2&quot;, &quot;1.3&quot; <br>  }<br> | <br>  {<br>    myArray: null<br>  },<br>  {<br>    myArray: &quot;1.1&quot;, &quot;1.2&quot;, &quot;1.3&quot; <br>  }<br> |

<b>Verbesserungen, die sich auf Kunden mit `ft-sites-97` enabled</b>
Kunden, die `ft-sites-97`*(GraphQL-Paginierung und optimierte Filterung)* Feature Flag aktiviert *before*-Version 2023.02.11382 kann nach der Aktualisierung auf 2023.02.11382 eine oder mehrere der folgenden Verhaltensänderungen auftreten. Kunden, für die diese Funktionskennzeichnung nicht aktiviert ist, sind von diesem Abschnitt nicht betroffen.
<b>Null-Handhabung mit Bedingungen, die auf Ungleichheit prüfen</b>
Fragmentfelder mit *null* -Werte wurden zeitweise nicht mit den Filtern abgeglichen, die auf Ungleichheit hin überprüft wurden.

Wenn Ihr Code darauf angewiesen ist, dass diese Fragmente nicht zurückgegeben werden, müssen Sie Ihren Code so anpassen, dass er dem erwarteten Verhalten entspricht.


| <b>Fragment filtern</b> | <b>Daten</b> | <b>Ergebnis der Zwischenimplementierung</b> | <b>Ergebnis der endgültigen Implementierung</b> |
| --- | --- | --- | --- |
| myField: {<br>  Wert: &quot;Beliebiger Text&quot;,<br>  _op: EQUALS_NOT<br>} | <br>  {<br>    myField: null<br>  },<br>  {<br>    myField: &quot;Beliebiger Text&quot;<br>  },<br>  {<br>    myField: &quot;Textfragment&quot;<br>  }<br> | <br>  {<br>    myField: &quot;Beliebiger Text&quot;<br>  }<br> | <br>  {<br>    myField: null<br>  },<br>  {<br>    myField: &quot;Beliebiger Text&quot;<br>  }<br> |

<b>Filteroperator `NOT_AT` mit Datums-/Uhrzeitwerten</b>
Filteroperator `NOT_AT` manchmal nicht ordnungsgemäß mit Daten-/Uhrzeitwerten funktionierte. Stattdessen funktionierte es eher wie das `AFTER` Bedingung. 
Wenn sich Ihr Code auf das falsche Verhalten stützt, sollten Sie die Filterbedingung auf `AFTER`.
<b>Arrays: `INSTANCES` mit `_instances: 0` nicht ordnungsgemäß funktioniert</b>
Filterbedingung `INSTANCES` (auf Arrays/Mehrwert-Feldern) mit `_instances` auf 0 gesetzt wurde, was nicht erwartungsgemäß funktioniert hat, gab es nichts zurück, was eigentlich hätte enthalten sein sollen.

Filtern Sie Fragmente, die von diesem Problem betroffen sind, wie folgt: `doubleArray: { _expressions: { value: 0, _operator: GREATER, _apply: INSTANCES, _instances: 0 } }`

Wenn Sie sich auf das fehlerhafte Verhalten verlassen haben, müssen Sie Ihre Abfrage neu schreiben, um dieselben Ergebnisse wie zuvor zurückzugeben.


| <b>Fragment filtern</b> | <b>Daten</b> | <b>Ergebnis der Zwischenimplementierung</b> | <b>Ergebnis der endgültigen Implementierung</b> |
| --- | --- | --- | --- |
| myArray: {<br>  _ausdrücke: {<br>    Wert: 20<br>    _operator: GLEICH<br>    _apply: INSTANZEN<br>    _instances: 0<br>  }<br>} | <br>  {<br>    myArray: null<br>  },<br>  {<br>    myArray: 10, 20, 30 <br>  },<br>  {<br>    myArray: 11, 12, 13 <br>  }<br> |  | <br>  {<br>    myArray: null<br>  },<br>  {<br>    myArray: 11, 12, 13 <br>  }<br> |

