---
title: Campaign Classic - Inkrementelle Abfrage ruft alle Datensätze ab, statt nur neue zu verwenden
description: Beschreibung
solution: Campaign
product: Campaign
applies-to: Campaign Classic
keywords: KCS
resolution: Resolution
internal-notes: Ticket = TK197178
bug: true
article-created-by: Marta Zator
article-created-date: 5/10/2022 9:47:14 AM
article-published-by: Marta Zator
article-published-date: 5/10/2022 9:51:21 AM
version-number: 2
article-number: KA-15190
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ad8bd527-46d0-ec11-a7b5-00224809c101
exl-id: f3dee0a7-8047-4949-9162-de95ba07fa7f
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '508'
ht-degree: 0%

---

# Campaign Classic - Inkrementelle Abfrage ruft alle Datensätze ab, statt nur neue zu verwenden

## Beschreibung


Der Kunde verfügt über mehrere inkrementelle Abfragen, die nicht erwartungsgemäß funktionieren. Anstatt nur neue Datensätze seit der letzten Ausführung aufzunehmen, greifen sie alle Datensätze jedes Mal auf - wie bei einer normalen Abfrageaktivität.


## Auflösung


Der Schuldige ist der Bereinigungs-Workflow.

Der inkrementelle Abfrage-Workflow funktioniert folgendermaßen:

0. Verlaufstabelle mit Ergebnissen aus früheren Iterationen verwalten
1. Rufen Sie ALLE Zeilen aus der Zielabfrage ab.
2. Filtern aller in der Verlaufstabelle vorhandenen Zeilen
3. Fügen Sie die verbleibenden Ergebnisse zur nächsten Iterationsfilterung in die Verlaufstabelle ein.

Der Name dieser Verlaufs-Arbeitstabelle weist die folgende Notation auf:
*wkfhistoworkflowid* activityName_

Jetzt für workflowIDs 0 (für Kunden, bei denen die Variable `xtknewid` Negative Sequenzen) sehen wir, dass es sich tatsächlich um Folgendes handelt:

*wkfhisto(uint)workflowid* activityName_

Dies ist zwar für die Ausführung des Workflows geeignet.

Beispielsweise die inkrementelle Aktivität `incremental1` von Workflow-ID=-1 erstellt eine Tabelle `wkfhisto4294967295_incremental1`.

Was fehlt, ist der CleanUp-Workflow.

Hier finden Sie einen Code, der versucht, Arbeitstabellen gelöschter Workflows zu löschen.

Ein dedizierter Code listet hier alle wkfhisto\*-Tabellen auf, extrahiert die workflowId aus ihren Namen (aus der obigen Konvention) und löscht sie alle außer denen, deren workflowIDs in der xtkworkflow-Tabelle gefunden werden.

Die `uint` Teil.

Es versucht also, einen Workflow mit der ID 4294967295 nachzuschlagen, anstatt ihn zurück an int zu senden. Da dieser Workflow nicht gefunden wird, wird diese Tabelle gelöscht. Wenn dieser Workflow das nächste Mal ausgeführt wird, findet die Aktivität &quot;Inkrementelle Abfrage&quot;keine existierende Verlaufstabelle und erstellt sie so, dass sie diese als erste Ausführung überhaupt betrachtet.

<b>Fehlerbehebung:</b>

Die Behebung dieses Problems ist in der Adobe Campaign Classic-Version 20.1.1 (Build 9122 und höher) verfügbar.

<b>Problemumgehungen, die Kunden verwenden können:</b>

Problemumgehung 1: Beenden Sie den Bereinigungs-Workflow und führen Sie ihn gelegentlich aus, um die Datenbank und die Festplatte zu bereinigen, bis die Korrektur ausgeführt und verfügbar ist. Nicht empfohlen, wenn Sie kein geplantes Upgrade durchführen.

Problemumgehung 2: Angenommen, die Aktivität &quot;Inkrementelle Abfrage&quot;wirkt sich auf diese aus und umgeht sie, indem sie dasselbe wie die inkrementelle Abfrage tut, indem ein persistentes Schema erstellt wird, in dem die Verlaufstabelle gespeichert werden soll. Verwenden Sie eine Kombination aus Abfrage- und Daten-Update-Aktivitäten, um das Verhalten zu imitieren. Dies muss für alle Workflows durchgeführt werden, die eine inkrementelle Abfrage erfordern.

Problemumgehung 3:  Angenommen, die inkrementelle Abfrageaktivität wirkt sich darauf aus und umgeht sie, indem dem betreffenden Schema ein Audit-Feld (tsCreated/tsLastModified) hinzugefügt wird. Ihre inkrementelle Abfrage wird dann in eine normale Abfrageaktivität mit einer WHERE-Klausel wie `tscreated GetDate()`.

Problemumgehung 4:

- Erstellen Sie eine neue Sequenz &quot;xtknewworkflowid&quot;und initialisieren Sie sie in eine Sequenz, die weit von den aktuellen workflowId-Bereichen entfernt ist.
- Ändern Sie das xtkworkflow-Schema zur Verwendung dieser pkSequence
- Bitten Sie den Kunden, alle betroffenen Workflows zu klonen und die ursprünglichen zu löschen.
- Sobald der Kunde für ein Upgrade bereit ist, entfernen Sie diese Fehlerbehebung, indem Sie für die Workflow-Erstellung auf xtknownId zurücksetzen (um unerwünschte Überraschungen zu vermeiden).
