---
title: "Inkrementelle Abfrage sammelt alle Datensätze anstelle nur neuer."
description: Beschreibung
solution: Campaign
product: Campaign
applies-to: "Campaign Classic"
keywords: "KCS"
resolution: Resolution
internal-notes: "Ticket = TK197178"
bug: true
article-created-by: Tanay Sharma .
article-created-date: "9/26/2022 10:11:48 AM"
article-published-by: Tanay Sharma .
article-published-date: "9/26/2022 11:03:23 AM"
version-number: 3
article-number: KA-15190
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e647789f-833d-ed11-9db1-002248086735"
source-git-commit: c07227262cb059b09254e8e1ec01542d4de2a881
workflow-type: tm+mt
source-wordcount: '353'
ht-degree: 0%

---

# Inkrementelle Abfrage ruft alle Datensätze statt nur neuer auf

## Beschreibung

<b>Umgebung</b>
Campaign Classic


<b>Problem/Symptome</b>
Inkrementelle Abfragen funktionieren nicht erwartungsgemäß. Statt seit der letzten Ausführung neue Datensätze zu erfassen, werden alle Datensätze wie eine normale Abfrageaktivität jedes Mal erfasst.


## Auflösung


Dieses Problem wurde in der Adobe Campaign Classic-Version 20.1.1 (Build 9122 und höher) behoben.

<b>Problemumgehungen, die Kunden verwenden können:</b>

<b>Problemumgehung 1</b>: Beenden Sie den Bereinigungs-Workflow und führen Sie ihn zeitweise aus, um die Datenbank und die Festplatte zu bereinigen, bis die Korrektur ausgeführt und verfügbar ist. Es wird nicht empfohlen, wenn Sie kein geplantes Upgrade durchführen.

<b>Problemumgehung 2</b>: Angenommen, die Aktivität &quot;Inkrementelle Abfrage&quot;ist betroffen. Gehen Sie dazu genauso vor wie bei der inkrementellen Abfrage, indem Sie ein beständiges Schema erstellen, in dem die Verlaufstabelle gespeichert werden soll. Verwenden Sie eine Kombination aus Abfrage- und Daten-Update-Aktivitäten, um das Verhalten zu imitieren. Dies muss für alle Workflows durchgeführt werden, die eine inkrementelle Abfrage erfordern.

<b>Problemumgehung 3</b>:  Angenommen, die Aktivität &quot;Inkrementelle Abfrage&quot;ist betroffen. Umgehen durch Hinzufügen eines Prüffelds `tsCreated/tsLastModified` dem betreffenden Schema. Ihre inkrementelle Abfrage wird dann in eine normale Abfrageaktivität mit einer where-Klausel wie `created GetDate()&#39; umgewandelt.

<b>Problemumgehung 4</b>:

1. Neue Sequenz erstellen `xtknewworkflowid` und initialisieren Sie sie in etwas weit von den aktuellen WorkflowId-Bereichen entfernt.
2. Ändern Sie die `xtkworkflow` Schema, das diese verwendet `pkSequence`.
3. Bitten Sie den Kunden, alle betroffenen Workflows zu klonen und die ursprünglichen zu löschen.
4. Sobald der Kunde für ein Upgrade bereit ist, entfernen Sie diese Fehlerbehebung, indem Sie zu `xtknewId` für die Workflow-Erstellung (um unerwünschte Überraschungen zu vermeiden).

<b>Ursache</b>
Der Schuldige ist der Bereinigungs-Workflow.

Der inkrementelle Abfrage-Workflow funktioniert folgendermaßen:

1. Führt eine Verlaufstabelle mit Ergebnissen aus früheren Iterationen auf.
2. Ruft alle Zeilen aus der Zielabfrage ab.
3. Filtert alle in der Verlaufstabelle vorhandenen Zeilen heraus
4. Fügt die verbleibenden Ergebnisse zur nächsten Iterationsfilterung zur Verlaufstabelle hinzu.


Der Name dieser Verlaufs-Arbeitstabelle weist die folgende Notation auf:
`wkfhistoworkflowid` `activityName_`

Jetzt für workflowIDs 0 (für Kunden, bei denen die Variable `xtknewid` Negative Sequenzen) sehen wir, dass es sich tatsächlich um Folgendes handelt:

`wkfhisto(uint)workflowid``activityName_`

`Although this is okay for workflow execution.`

`So, for example, the incremental activity incremental1 of workflow ID=-1 will create a table wkfhisto4294967295_incremental1`&quot;

`The thing which is missed is the CleanUp workflow.`

`Here, we have a code that tries to delete worktables of deleted workflows.`

`A dedicated code here lists all the wkfhisto tables, extracts the workflowId from their names (from the above convention), and deletes them all except the ones whose worklowIDs are found in the xtkworkflow table.`

`However, it misses the uint part.`

`So, it tries to look up a workflow with ID 4294967295 instead of casting this back to int. Since this workflow is not found, this table is deleted. Next time, when this workflow runs, the incremental query activity does not find an existing history table and creates it thinking of this as the first run ever.`
