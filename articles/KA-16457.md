---
title: "SegmentNotFoundException and IllegalArgumentException"
description: Beschreibung
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: "Helpx Link: https://helpx.adobe.com/experience-manager/kb/offline-compaction-fails-with-SegmentNotFoundException-and-IllegalArgumentException.html"
bug: false
article-created-by: Emily Geary
article-created-date: "4/12/2021 6:09:12 PM"
article-published-by: Emily Geary
article-published-date: "4/12/2021 6:09:50 PM"
version-number: 7
article-number: KA-16457
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=7ed24a2d-ba9b-eb11-b1ac-000d3a3680d8"
exl-id: 54f6bac4-f81b-4685-89e6-eaedf60f3552
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '956'
ht-degree: 0%

---

# SegmentNotFoundException und IllegalArgumentException

## Beschreibung


Das Ausführen einer Offline-Verdichtung kann mit SegmentNotFoundException fehlschlagen, wenn Integritätsprobleme des Repositorys auftreten.

Sie beobachten SegmentNotFoundException in AEM Protokolldateien und AEM funktioniert nicht erwartungsgemäß

OR

Das Ausführen einer Offline-Verdichtung kann mit SegmentNotFoundException fehlschlagen, wenn Integritätsprobleme des Repositorys auftreten. Eine Stapelspur, die der unten stehenden ähnelt, finden Sie in den Protokollen:

`13:51:21.523 main ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 4d139bc4-150c-4f0a-b82a-40a4e519fe8a. Creation ` `date` `delta is 4 ms.`

`org.apache.jackrabbit.oak.plugins.segment.SegmentNotFoundException: Segment 4d139bc4-150c-4f0a-b82a-40a4e519fe8a not found`

`at org.apache.jackrabbit.oak.plugins.segment.` `file` `.FileStore.readSegment(FileStore.java:855) oak-run-1.0.22.jar:1.0.22`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentTracker.getSegment(SegmentTracker.java:134)  oak-run-1.0.22.jar:1.0.22`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentId.getSegment(SegmentId.java:101) oak-run-1.0.22.jar:1.0.22`

`...`

`Exception ` `in` `thread ` `"main"` `org.apache.jackrabbit.oak.plugins.segment.SegmentNotFoundException: Segment 4d139bc4-150c-4f0a-b82a-40a4e519fe8a not found`

`at org.apache.jackrabbit.oak.plugins.segment.` `file` `.FileStore.readSegment(FileStore.java:855)`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentTracker.getSegment(SegmentTracker.java:134)`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentId.getSegment(SegmentId.java:101)`

`...`

ODER

Das Ausführen einer Offline-Verdichtung kann mit IllegalArgument Exception fehlschlagen, wenn Integritätsprobleme des Repositorys vorliegen. Eine Stapelspur, die der unten stehenden ähnelt, finden Sie in den Protokollen:


| `java.lang.IllegalArgumentException`<br><br>`at com.google.common.base.Preconditions.checkArgument(Preconditions.java:77)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.(ListRecord.java:41)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntry(ListRecord.java:64)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntries(ListRecord.java:81)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentStream.` `read` `(SegmentStream.java:153)`<br><br>`at org.apache.jackrabbit.oak.commons.IOUtils.readFully(IOUtils.java:53)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.getBlobKey(Compactor.java:412)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.compact(Compactor.java:362)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.compact(Compactor.java:321)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.access$500(Compactor.java:54)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.propertyAdded(Compactor.java:227)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.propertyAdded(CancelableDiff.java:47)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:156)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)` |
| --- |


<b>Ursache</b>

Eine SegmentNotFoundException wird zurückgegeben, wenn ein Segment nicht vorhanden ist, während die Komprimierung versucht, den Knoten zu lesen. Dafür kann es verschiedene Ursachen geben:

1. Das Segment wurde durch manuelles Eingreifen (z. B. rm -rf /) entfernt.
2. Das Segment wurde durch die Revisionsbereinigung entfernt.
3. Das Segment kann aufgrund eines Fehlers im Code nicht gefunden werden.


Falls das Problem durch die Revisionsbereinigung verursacht wird (Punkt 2), stellen Sie sicher, dass die Online-Komprimierung deaktiviert ist, um zu verhindern, dass weitere Knoten beschädigt werden.


## Auflösung


Es gibt mehrere Verfahren, die wir befolgen können, um die Situation zu beheben und die Offline-Verdichtung erfolgreich abzuschließen.

*Wichtig:* Führen Sie eine vollständige Sicherung Ihres Repositorys durch, bevor Sie die folgenden Schritte ausführen.



<b>A. Kehren Sie zur letzten zweifelsfrei funktionierenden Revision des Segmentspeichers zurück.</b>

Der Ausführungsmodus &quot;Überprüfen&quot;von oak-run kann verwendet werden, um die letzte zweifelsfrei funktionierende Revision eines Segmentspeichers zu ermitteln. Dies kann verwendet werden, um einen beschädigten Segmentspeicher manuell auf die neueste gute Revision zurückzusetzen.

*Vorsicht:<b>* </b>Durch diesen Prozess werden die Daten im System zu einem früheren Zeitpunkt zurückgesetzt.  Wenn Sie vermeiden möchten, dass Änderungen in Ihrem System verloren gehen, können Sie stattdessen Option B verwenden.

So führen Sie die Prüfung durch und stellen Folgendes wieder her:

1. Laden Sie die JAR-Datei mit Oak-Run von hier herunter [http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/](http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/)
2. Hör auf AEM.
3. Führen Sie diesen Befehl aus:

   `java -jar oak-run-*.jar check --bin=-1 crx-quickstart/repository/segmentstore/`



   Dieser Befehl durchsucht die Revisionen rückwärts, bis er einen konsistenten findet:

   `14:00:30.783 main INFO  o.a.j.o.p.s.f.t.ConsistencyChecker - Found latest good revision afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880`



   (Falls der ConsistencyChecker fehlschlägt, gehen Sie zum nächsten Abschnitt.)


4. Stellen Sie das Repository durch Bearbeiten auf diese Revision zurück.

   `/crx-quickstart/repository/segmentstore/journal.log.`



   Löschen Sie alle Zeilen nach der Zeile, die die neueste gute Revision enthält. Wenn Sie herausfinden möchten, zu welchem Datum und zu welcher Uhrzeit Sie das Repository wiederherstellen, führen Sie diesen Befehl im Segmentstore-Ordner aus (ersetzen Sie afdb922d-ba53-4a1b-aa1b-1cb044b535cf durch die neueste gute Revision in Ihrem journal.log):

   `find . -type f -name "data*.tar" -exec sh -c "tar -tvf {} |grep afdb922d-ba53-4a1b-aa1b-1cb044b535cf" \; -print`



   Die Ausgabe zeigt Ihnen ein ungefähres Datum und eine ungefähre Uhrzeit dieser Revision.


5. Alle entfernen `./crx-quickstart/repository/segmentstore/*.bak files.`
6. Wenn Sie AEM6.0 verwenden, laden Sie die Oak-Run-Version herunter, die mit den in AEM für die restlichen Schritte installierten Versionen übereinstimmt.  Herunterladen von hier [http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/](http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/).
7. Führen Sie eine Checkpoint-Bereinigung aus, um verwaiste Checkpoints zu entfernen:

   `java -jar oak-run-*.jar checkpoints ./crx-quickstart/repository/segmentstore rm-unreferenced.`


8. Komprimieren Sie schließlich das Repository:

   `java -jar oak-run-*.jar compact ./crx-quickstart/repository/segmentstore/`




<b>B. Entfernen Sie beschädigte Knoten manuell.</b>

In AEM TarMK-Setups ohne konfigurierten FileDatastore und in Situationen, in denen die Binärdateien beschädigt sind, können Sie Folgendes tun.

*Vorsicht:*Die unten beschriebene Vorgehensweise ist für Power-User gedacht.  Beim Löschen der beschädigten Knoten müssen Sie sicherstellen, dass es sich nicht um Systemknoten handelt (z. B. /home, /jcr:system usw.).  Oder wenn es sich um Systemknoten handelt, müssen Sie sicherstellen, dass Sie diese wiederherstellen können.  Wenden Sie sich an AEM Kundenunterstützungs-Team, um Unterstützung bei den hier beschriebenen Schritten zu erhalten, wenn Sie sich nicht sicher sind.

1. Hör auf AEM.
2. Verwenden Sie die Oak-Ausführungskonsole und laden Sie das childCount-Groovy-Skript, um die beschädigten Knoten im Segmentspeicher zu identifizieren:

   Laden Sie die Oak-Run-Konsolenshell:

   `java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore`



   Führen Sie die beiden folgenden Befehle in der Shell aus, um das Skript zu laden und auszuführen:

   `:load`

   `https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy`

   `countNodes(session.workingNode)`



   Dies führt zur folgenden Ausgabe, die den Pfad zu den beschädigten Knoten angibt:

   `21:21:42.029 main ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. Creation date delta is 3 ms.`

   `warning unable to read node /content/dam/test.txt/jcr:content/renditions/original/jcr:content`



   In einigen Fällen ist das Problem mit binären Eigenschaften verknüpft und das childCount Groovy-Skript kann keine beschädigten Knoten finden.  In diesen Fällen können Sie stattdessen den folgenden Befehl verwenden, der die ersten 1024 Byte für jede während der Durchlaufphase aufgefundene Binärdatei liest (beachten Sie, dass dieser Befehl langsamer ist und nur verwendet werden sollte, wenn das oben genannte nicht die erwarteten Ergebnisse zurückgibt):

   `countNodes(session.workingNode,true)`


3. Entfernen Sie alle identifizierten beschädigten Knoten, die in der Ausgabe des letzten Befehls mit rmNodes.groovy aufgeführt sind.

   Laden Sie die Oak-Run-Konsolenshell:

   `java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore`



   Laden Sie das Groovy-Skript:

   `:load`

   `https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy`



   Führen Sie den Befehl rmNode aus, um den beschädigten Knoten zu entfernen, ersetzen Sie /path/to/corrupt/node durch den Pfad zum beschädigten Knoten, den Sie entfernen müssen.

   `rmNode(session, "/path/to/corrupt/node")`



   Wobei der beschädigte Knotenpfad der in Schritt 2 abgerufene Pfad ist, z. B.: `"/content/dam/test.txt/jcr:content/renditions/original/jcr:content/"`
Hinweis: Wenn Sie oak-run.jar Version 1.6.13 und höher verwenden, setzen Sie den JVM-Parameter —read-write , wenn ein Fehler wie folgt auftritt:






   ```
   / rmNode(session,"/path/to/corrupt/node")    Removing node /path/to/corrupt/node    ERROR java.lang.UnsupportedOperationException:    Cannot write to read-only store    at org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171)    at org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318)    at org.apache.jackrabbit.oak.segment.SegmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:111)    at org.apache.jackrabbit.oak.segment.SegmentNodeStore$Commit.init (SegmentNodeStore.java:581)    at org.apache.jackrabbit.oak.segment.SegmentNodeStore.merge (SegmentNodeStore.java:333)    at org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (Unknown Source)    at groovysh_evaluate.rmNode (groovysh_evaluate:11)
   ```

4. Wiederholen Sie Schritt 3 für alle in Schritt 2 gefundenen Knoten.

   Dieser obige rmNode-Befehl sollte für den beschädigten Pfad &quot;true&quot;zurückgeben, was bedeutet, dass er ihn gelöscht hat. Stellen Sie sicher, dass diese drei gefundenen beschädigten Pfade gelöscht werden, indem Sie den Befehl rmNode auf diesen Pfaden erneut ausführen. Bei der nächsten Ausführung sollte &quot;false&quot;zurückgegeben werden.

   Wenn Sie immer noch sehen, dass dieselben Pfade im Repository vorhanden sind, verwenden Sie die gepatchte Version von oak-run jar, d. h. oak-run-1.2.18-NPR-17596

   Was tut die gepatchte Version von Oak Run Jar?

   Diese Version von jar überspringt unlesbare Binärdateien bei der Komprimierung, indem sie durch 0-Byte-Binärdateien ersetzt und die Ausnahme und der Pfad zum Server protokolliert werden. Das so komprimierte Repository sollte dann die oak-run-Prüfung, das Knotenzählungsskript, übergeben und Sie sollten es auch mit einem nicht gepatchten Oak-Run erneut komprimieren können.


5. Führen Sie eine Checkpoint-Bereinigung durch, indem Sie Checkpoints wie unten beschrieben auflisten. Wenn es mehr als einen Checkpoint gibt, bereinigen Sie ihn:

   `nohup java -Xmx4096m -jar oak-run-1.2.18.jar checkpoints /app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out &`
6. Führen Sie eine Offline-Komprimierung aus.  Wenn Sie nicht wissen, wie Sie die Offline-Verdichtung ausführen, lesen Sie [here](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).
7. Starten Sie den Server und warten Sie, bis die Indizierung abgeschlossen ist.
