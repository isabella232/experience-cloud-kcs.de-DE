---
title: Grundlagen zum Zwischenspeichern
description: Beschreibung
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: 2/7/2022 5:13:07 PM
article-published-by: Roxann McGlumphy
article-published-date: 2/7/2022 5:13:28 PM
version-number: 3
article-number: KA-17912
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ee0f4935-3988-ec11-93b0-0022480837ff
exl-id: a5da3fc9-c0a0-4d5a-8369-a96dad9e2b49
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1517'
ht-degree: 1%

---

# Grundlagen zum Zwischenspeichern

## Beschreibung

In diesem Dokument wird erklärt, wie das Dispatcher-Caching erfolgt und wie es konfiguriert werden kann<br><br> <br><br>[Inhaltsverzeichnis](https://experienceleague.adobe.com/docs/experience-cloud-kcs/kbarticles/KA-17490.html?lang=de)

## Auflösung


<b>Zwischenspeichern von Ordnern</b>

Wir verwenden die folgenden standardmäßigen Cache-Ordner in unseren Basisinstallationen

- Autor

   - /mnt/var/www/author
- Veröffentlicher

   - /mnt/var/www/html


Wenn jede Anfrage den Dispatcher durchläuft, befolgen die Anforderungen die konfigurierten Regeln, um eine lokal zwischengespeicherte Version auf Antwort der zulässigen Elemente beizubehalten

<b>Hinweis:</b>

Die veröffentlichte Arbeitslast wird absichtlich von der Arbeitslast des Autors getrennt, da Apache beim Suchen nach einer Datei im DocumentRoot nicht weiß, von welcher AEM Instanz sie stammt. Selbst wenn Sie also den Cache in der Autorenfarm deaktiviert haben, werden Dateien aus dem Cache bereitgestellt, wenn der DocumentRoot des Autors mit dem Publisher übereinstimmt. Das bedeutet, dass Sie Autorendateien für aus dem veröffentlichten Cache bereitstellen und für ein wirklich schreckliches Mix-Match-Erlebnis für Ihre Besucher sorgen. Die Beibehaltung separater DocumentRoot-Ordner für verschiedene veröffentlichte Inhalte ist ebenfalls eine schlechte Idee. Sie müssen mehrere erneut zwischengespeicherte Elemente erstellen, die sich nicht zwischen Sites wie Clientlibs unterscheiden, und für jeden von Ihnen eingerichteten DocumentRoot einen Replikations-Flush-Agenten einrichten. Erhöhen Sie mit jeder Seitenaktivierung den Verwaltungsaufwand. Verlassen Sie sich auf den Namespace von Dateien und deren vollständig zwischengespeicherten Pfaden und vermeiden Sie mehrere DocumentRoot-Pfade für veröffentlichte Sites.



<b>Konfigurationsdateien</b>

Der Dispatcher steuert, was im Abschnitt /cache { einer Farm-Datei als zwischenspeicherbar gilt. 
In den AMS-Grundlinien-Konfigurationsfarmen finden Sie unsere Includes wie unten gezeigt:


```
/cache { 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    }
```


Informationen zum Erstellen der Regeln für das Zwischenspeichern finden Sie in der Dokumentation . [here](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)



<b>Caching-Autor</b>

Es gibt viele Implementierungen, die wir gesehen haben, in denen Benutzer keine Autoreninhalte zwischenspeichern. 
Sie vermissen ein enormes Upgrade der Leistung und Reaktionsfähigkeit ihrer Autoren.

Sprechen wir über die Strategie, die bei der Konfiguration unserer Autoren-Farm für den richtigen Cache verwendet wurde.

Im Folgenden finden Sie einen grundlegenden Abschnitt zum Autor /cache { unserer Farm-Datei:


```
/cache { 
    /docroot "/mnt/var/www/author" 
    /statfileslevel "2" 
    /allowAuthorized "1" 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    } 
    /invalidate { 
        /0000 { 
            /glob "*" 
            /type "allow" 
        } 
    } 
    /allowedClients { 
        /0000 { 
            /glob "*.*.*.*" 
            /type "deny" 
        } 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_invalidate_allowed.any" 
    } 
}
```


Wichtig ist hier, dass die <b>/docroot</b> auf das Cache-Verzeichnis für Autor festgelegt ist.

<b>Hinweis:</b>

Stellen Sie sicher, dass DocumentRoot in der Vhost-Datei des Autors mit dem Parameter farms /docroot übereinstimmt.

Die Include-Anweisung der Cache-Regeln enthält die -Datei <b>/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any</b> , der die folgenden Regeln enthält:


```
/0000 { 
 /glob "*" 
 /type "deny" 
} 
/0001 { 
 /glob "/libs/*" 
 /type "allow" 
} 
/0002 { 
 /glob "/libs/*.html" 
 /type "deny" 
} 
/0003 { 
 /glob "/libs/granite/csrf/token.json" 
 /type "deny" 
} 
/0004 { 
 /glob "/apps/*" 
 /type "allow" 
} 
/0005 { 
 /glob "/apps/*.html" 
 /type "deny" 
} 
/0006 { 
 /glob "/libs/cq/core/content/welcome.*" 
 /type "deny" 
}
```


In einem Autorenszenario ändert sich der Inhalt ständig und absichtlich. Sie möchten nur Elemente zwischenspeichern, die sich nicht häufig ändern.
Wir verfügen über Regeln zum Zwischenspeichern von /libs, da diese Teil der grundlegenden AEM-Installation sind und sich ändern würden, bis Sie ein Service Pack, ein kumulatives Fixpack, ein Upgrade oder Hotfix installiert haben. Das Zwischenspeichern dieser Elemente ist also sehr sinnvoll und bietet wirklich große Vorteile für die Autorenerfahrung von Endbenutzern, die die Site nutzen.

<b>Hinweis:</b>

Beachten Sie, dass diese Regeln auch zwischenspeichern <b>/apps</b> Hier lebt benutzerdefinierter Anwendungscode. Wenn Sie Ihren Code auf dieser Instanz entwickeln, wird es sich beim Speichern Ihrer Datei als sehr verwirrend erweisen und nicht sehen, ob der Code in der Benutzeroberfläche angezeigt wird, da eine zwischengespeicherte Kopie bereitgestellt wird. Wenn Sie Ihren Code in AEM implementieren, ist dies nur selten der Fall und Teil Ihrer Implementierungsschritte sollte darin bestehen, den Autoren-Cache zu leeren. Auch hier ist der Vorteil enorm, dass Ihr zwischenspeicherbarer Code für die Endbenutzer schneller ausgeführt werden kann.



<b>ServeOnStale (AKA-Serve auf Stale/SOS)</b>

Dies ist einer der Edelsteine einer Funktion des Dispatchers. Wenn der Herausgeber unter Last ist oder nicht mehr reagiert, wird normalerweise ein HTTP-Antwortcode 502 oder 503 ausgegeben. Wenn dies eintritt und diese Funktion aktiviert ist, wird der Dispatcher angewiesen, weiterhin den Inhalt bereitzustellen, der sich immer noch im Cache befindet, selbst wenn es sich nicht um eine neue Kopie handelt. Es ist besser, etwas zu bedienen, wenn Sie es haben, anstatt nur eine Fehlermeldung anzuzeigen, die keine Funktionalität bietet.

<b>Hinweis:</b>

Beachten Sie, dass diese Funktion nicht Trigger wird, wenn der Herausgeber-Renderer eine Socket-Zeitüberschreitung oder eine Fehlermeldung von 500 aufweist. Wenn AEM einfach nicht erreichbar ist, bewirkt diese Funktion nichts

Diese Einstellung kann in jeder Farm festgelegt werden, es ist jedoch nur sinnvoll, sie auf die Farm-Dateien im Veröffentlichungsmodus anzuwenden. Im Folgenden finden Sie ein Syntaxbeispiel der Funktion, die in einer Farm-Datei aktiviert ist:


```
/cache { 
    /serveStaleOnError "1"
```




<b>Zwischenspeichern von Seiten mit Abfrageparametern/Argumenten</b>

<b>Hinweis:</b>

Eines der normalen Verhaltensweisen des Dispatcher-Moduls besteht darin, dass eine Anfrage einen Abfrageparameter im URI hat (normalerweise angezeigt wie /content/page.html).<b>?myquery=value</b>) wird das Zwischenspeichern der Datei übersprungen und direkt zur AEM Instanz geleitet. Sie erwägt, dass diese Anfrage eine dynamische Seite ist und nicht zwischengespeichert werden sollte. Dies kann Auswirkungen auf die Cache-Effizienz haben.

Wenn Sie Seiten in AEM haben, die GET/Abfrageparameter in der Adresszeile verwenden, die die Seitenfunktion unterstützen, aber unterschiedliche HTML-Seiten nicht rendern, sind gute Kandidaten für dieses Konfigurationselement. Sie können dem Dispatcher mitteilen, welche Argumente ignoriert werden sollen und die Seite dennoch zwischenspeichern.
Beispiel: jemand hat einen Deep-Link-Referenzmechanismus für soziale Medien erstellt, der die Argumentreferenz im URI verwendet, um zu erfahren, woher die Person stammt.

<b>Beispiel:</b>

[https://www.retail.com/home.html?reference=android](https://www.retail.com/home.html?reference=android)

[https://www.retail.com/home.html?reference=facebook](https://www.retail.com/home.html?reference=facebook)

Die Seite kann zu 100 % zwischengespeichert werden, jedoch nicht zwischengespeichert werden, da die Argumente vorhanden sind. 
Um dies zu umgehen, fügen wir den folgenden Abschnitt zu unserer Farm-Konfigurationsdatei hinzu:


```
/cache { 
    /ignoreUrlParams { 
        /0001 { /glob "*" /type "deny" } 
        /0002 { /glob "reference" /type "allow" } 
    }
```


Wenn der Dispatcher nun die Anfrage sieht, wird ignoriert, dass die Anfrage den Abfrageparameter ?reference aufweist und die Seite trotzdem zwischenspeichert



<b>Zwischenspeichern von Antwortheadern</b>

Es ist ziemlich offensichtlich, dass der Dispatcher HTML-Seiten und Clientlibs zwischenspeichert. Wussten Sie jedoch, dass er bestimmte Antwort-Header neben dem Inhalt in einer Datei mit demselben Namen, aber einer .h-Dateierweiterung zwischenspeichern kann? Dadurch kann die nächste Antwort nicht nur auf den Inhalt, sondern auch auf die Antwortheader angewendet werden, die aus dem Cache gesendet werden sollen.

AEM kann mehr als nur UTF-8-Kodierung verarbeiten

Manchmal verfügen Elemente über spezielle Header, mit denen die Codierungsdetails der TTL-Cache-Datei und die zuletzt geänderten Zeitstempel gesteuert werden können.

Diese Werte beim Zwischenspeichern werden standardmäßig entfernt und der Apache-HTTPD-Webserver übernimmt die Verarbeitung des Assets mit den normalen Dateibearbeitungsmethoden, die normalerweise auf die anhand von Dateierweiterungen berechnete MIME-Typen beschränkt sind.

Wenn der Dispatcher das Asset und die gewünschten Header zwischenspeichert, können Sie das richtige Erlebnis bereitstellen und sicherstellen, dass alle Details dem Client-Browser entsprechen.

Im Folgenden finden Sie ein Beispiel für eine Farm mit den Headern, die zwischengespeichert werden sollen:


```
/cache { 
 /headers { 
  "Cache-Control" 
  "Content-Disposition" 
  "Content-Type" 
  "Expires" 
  "Last-Modified" 
  "X-Content-Type-Options" 
 } 
}
```


In dem Beispiel, für das sie AEM zum Bereitstellen von Headern konfiguriert haben, prüft das CDN, wann der Cache invalidiert werden soll. Das bedeutet nun, AEM kann ordnungsgemäß bestimmen, welche Dateien basierend auf Headern invalidiert werden.

<b>Hinweis:</b>

Beachten Sie, dass Sie keine regulären Ausdrücke oder glob-Übereinstimmungen verwenden können. Es handelt sich um eine wörtliche Liste der Header, die zwischengespeichert werden sollen. Fügen Sie nur eine Liste der literalen Header ein, die zwischengespeichert werden sollen.



<b>Übergangsphase für automatische Invalidierung</b>

Auf AEM Systemen mit viel Aktivität von Autoren, die viele Seitenaktivierungen durchführen, kann es zu einer Race-Bedingung kommen, bei der wiederholte Invalidierungen auftreten. Erheblich wiederholte Leerungsanfragen sind nicht erforderlich und Sie können eine Toleranz aufbauen, um einen Leerlauf erst nach Ablauf der Übergangsphase zu wiederholen.

<b>Beispiel:</b>

Wenn Sie 5 Anfragen zur Invalidierung von /content/exampleco/en/ haben, erfolgen alle innerhalb von 3 Sekunden.

Mit dieser Funktion würden Sie das Cache-Verzeichnis /content/exampleco/en/ fünfmal invalidieren

Wenn diese Funktion aktiviert ist und auf 5 Sekunden festgelegt ist, wird das Cache-Verzeichnis /content/exampleco/en/ invalidiert<b>once</b>

Hier finden Sie eine Beispielsyntax dieser Funktion, die für eine Übergangsphase von 5 Sekunden konfiguriert wird:


```
/cache { 
    /gracePeriod "5"
```




<b>TTL-basierte Invalidierung</b>

Eine neuere Funktion des Dispatcher-Moduls war <b>Time to Live (TTL)</b> Optionen für die Invalidierung auf Basis der im Cache gespeicherten Elemente. Wenn ein Element zwischengespeichert wird, sucht es nach Cache-Steuerelement-Headern und generiert eine Datei im Cache-Verzeichnis mit demselben Namen und einer <b>.ttl</b> -Erweiterung.

Im Folgenden finden Sie ein Beispiel der Funktion, die in der Farm-Konfigurationsdatei konfiguriert wird:


```
/cache { 
    /enableTTL "1"
```


<b>Hinweis:</b>

Beachten Sie, dass AEM weiterhin so konfiguriert werden muss, dass TTL-Header gesendet werden, damit der Dispatcher sie berücksichtigt. Durch das Umschalten dieser Funktion kann der Dispatcher nur wissen, wann die Dateien entfernt werden sollen, für die AEM Cache-Steuerelement-Header gesendet hat. Wenn AEM nicht beginnt, TTL-Header zu senden, führt der Dispatcher hier keine besonderen Aktionen durch.



<b>Cache-Filterregeln</b>

Im Folgenden finden Sie ein Beispiel für eine Basiskonfiguration, für die Elemente in einem Publisher zwischengespeichert werden sollen:


```
/cache{ 
    /0000 { 
        /glob "*" 
        /type "allow" 
    } 
    /0001 { 
        /glob "/libs/granite/csrf/token.json" 
        /type "deny" 
    }
```


Wir möchten unsere veröffentlichte Site so gierig wie möglich machen und alles zwischenspeichern.

Wenn es Elemente gibt, die das Erlebnis beim Zwischenspeichern beschädigen, können Sie Regeln hinzufügen, um die Option zum Zwischenspeichern dieses Elements zu entfernen. Wie Sie im obigen Beispiel sehen, sollten die CSRF-Token nie zwischengespeichert und ausgeschlossen werden. Weitere Informationen zum Schreiben dieser Regeln finden Sie unter [here](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)
