---
title: Grundlagen zum Zwischenspeichern
description: Beschreibung
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: 2/7/2022 5:13:07 PM
article-published-by: Roxann McGlumphy
article-published-date: 2/7/2022 5:13:28 PM
version-number: 3
article-number: KA-17912
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ee0f4935-3988-ec11-93b0-0022480837ff
exl-id: a5da3fc9-c0a0-4d5a-8369-a96dad9e2b49
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: tm+mt
source-wordcount: '1462'
ht-degree: 1%

---

# Grundlagen zum Zwischenspeichern

## Beschreibung

In diesem Dokument wird erläutert, wie [!DNL dispatcher] Zwischenspeicherung erfolgt und wie sie konfiguriert werden kann<br><br>
[Inhaltsverzeichnis](https://experienceleague.adobe.com/docs/experience-cloud-kcs/kbarticles/KA-17490.html?lang=de)

## Auflösung


<b>Zwischenspeichern von Ordnern</b>

Wir verwenden die folgenden standardmäßigen Cache-Ordner in unseren Basisinstallationen

- Autor

   - `/mnt/var/www/author`
- Veröffentlicher

   - `/mnt/var/www/html`


Wenn jede Anforderung durch die [!DNL dispatcher] Die Anforderungen folgen den konfigurierten Regeln, um eine lokal zwischengespeicherte Version zu behalten, wenn die zulässigen Elemente antworten

<b>Hinweis:</b>

Die veröffentlichte Arbeitslast wird absichtlich von der Arbeitslast des Autors getrennt, da Apache beim Suchen nach einer Datei im DocumentRoot nicht weiß, von welcher AEM Instanz sie stammt. Selbst wenn Sie also den Cache in der Autorenfarm deaktiviert haben, werden Dateien aus dem Cache bereitgestellt, wenn der DocumentRoot des Autors mit dem Publisher übereinstimmt. Das bedeutet, dass Sie Autorendateien für aus dem veröffentlichten Cache bereitstellen und für ein wirklich schreckliches Mix-Match-Erlebnis für Ihre Besucher sorgen. Die Beibehaltung separater DocumentRoot-Ordner für verschiedene veröffentlichte Inhalte ist ebenfalls eine schlechte Idee. Sie müssen mehrere erneut zwischengespeicherte Elemente erstellen, die sich nicht zwischen Sites wie Clientlibs unterscheiden, und für jeden von Ihnen eingerichteten DocumentRoot einen Replikations-Flush-Agenten einrichten. Erhöhen Sie mit jeder Seitenaktivierung den Verwaltungsaufwand. Verlassen Sie sich auf den Namespace von Dateien und deren vollständig zwischengespeicherten Pfaden und vermeiden Sie mehrere DocumentRoot-Pfade für veröffentlichte Sites.



<b>Konfigurationsdateien</b>

[!DNL Dispatcher] steuert, was im `/cache {` -Abschnitt einer beliebigen Farm-Datei. 
In den AMS-Grundlinien-Konfigurationsfarmen finden Sie unsere Includes wie unten gezeigt:


```
/cache { 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    }
```


Informationen zum Erstellen der Regeln für das Zwischenspeichern finden Sie in der Dokumentation . [here](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)



<b>Caching-Autor</b>

Es gibt viele Implementierungen, die wir gesehen haben, in denen Benutzer keine Autoreninhalte zwischenspeichern. 
Sie vermissen ein enormes Upgrade der Leistung und Reaktionsfähigkeit ihrer Autoren.

Sprechen wir über die Strategie, die bei der Konfiguration unserer Autoren-Farm für den richtigen Cache verwendet wurde.

Hier finden Sie einen Basisautor `/cache {` Abschnitt unserer Autoren-Farm-Datei:


```
/cache { 
    /docroot "/mnt/var/www/author" 
    /statfileslevel "2" 
    /allowAuthorized "1" 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    } 
    /invalidate { 
        /0000 { 
            /glob "*" 
            /type "allow" 
        } 
    } 
    /allowedClients { 
        /0000 { 
            /glob "*.*.*.*" 
            /type "deny" 
        } 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_invalidate_allowed.any" 
    } 
}
```


Wichtig ist hier, dass die <b>`/docroot`</b> auf das Cache-Verzeichnis für Autor festgelegt ist.

<b>Hinweis:</b>

Stellen Sie sicher, dass `DocumentRoot` im `.vhost` Datei stimmt mit den Farmen überein `/docroot` parameter

Die Include-Anweisung der Cache-Regeln enthält die -Datei <b>`/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any`</b> , der die folgenden Regeln enthält:


```
/0000 { 
 /glob "*" 
 /type "deny" 
} 
/0001 { 
 /glob "/libs/*" 
 /type "allow" 
} 
/0002 { 
 /glob "/libs/*.html" 
 /type "deny" 
} 
/0003 { 
 /glob "/libs/granite/csrf/token.json" 
 /type "deny" 
} 
/0004 { 
 /glob "/apps/*" 
 /type "allow" 
} 
/0005 { 
 /glob "/apps/*.html" 
 /type "deny" 
} 
/0006 { 
 /glob "/libs/cq/core/content/welcome.*" 
 /type "deny" 
}
```


In einem Autorenszenario ändert sich der Inhalt ständig und absichtlich. Sie möchten nur Elemente zwischenspeichern, die sich nicht häufig ändern.
Wir verfügen über Regeln zum Zwischenspeichern `/libs` weil sie Teil der grundlegenden AEM-Installation sind und sich ändern würden, bis Sie ein Service Pack, ein kumulatives Fixpack, ein Upgrade oder Hotfix installiert haben. Das Zwischenspeichern dieser Elemente ist also sehr sinnvoll und bietet wirklich große Vorteile für die Autorenerfahrung von Endbenutzern, die die Site nutzen.

<b>Hinweis:</b>

Beachten Sie, dass diese Regeln auch zwischenspeichern <b>`/apps`</b> Hier lebt benutzerdefinierter Anwendungscode. Wenn Sie Ihren Code auf dieser Instanz entwickeln, wird es sich beim Speichern Ihrer Datei als sehr verwirrend erweisen und nicht sehen, ob der Code in der Benutzeroberfläche angezeigt wird, da eine zwischengespeicherte Kopie bereitgestellt wird. Wenn Sie Ihren Code in AEM implementieren, ist dies nur selten der Fall und Teil Ihrer Implementierungsschritte sollte darin bestehen, den Autoren-Cache zu leeren. Auch hier ist der Vorteil enorm, dass Ihr zwischenspeicherbarer Code für die Endbenutzer schneller ausgeführt werden kann.



<b>ServeOnStale (AKA-Serve auf Stale/SOS)</b>

Dies ist eines der Edelsteine eines Merkmals der [!DNL dispatcher]. Wenn der Herausgeber unter Last ist oder nicht mehr reagiert, wird normalerweise ein HTTP-Antwortcode 502 oder 503 ausgegeben. Wenn dies geschieht und diese Funktion aktiviert ist, wird die [!DNL dispatcher] wird angewiesen, weiterhin bereitzustellen, was immer noch Inhalt im Cache ist, selbst wenn es sich nicht um eine neue Kopie handelt. Es ist besser, etwas zu bedienen, wenn Sie es haben, anstatt nur eine Fehlermeldung anzuzeigen, die keine Funktionalität bietet.

<b>Hinweis:</b>

Beachten Sie, dass diese Funktion nicht Trigger wird, wenn der Herausgeber-Renderer eine Socket-Zeitüberschreitung oder eine Fehlermeldung von 500 aufweist. Wenn AEM einfach nicht erreichbar ist, bewirkt diese Funktion nichts

Diese Einstellung kann in jeder Farm festgelegt werden, es ist jedoch nur sinnvoll, sie auf die Farm-Dateien im Veröffentlichungsmodus anzuwenden. Im Folgenden finden Sie ein Syntaxbeispiel der Funktion, die in einer Farm-Datei aktiviert ist:


```
/cache { 
    /serveStaleOnError "1"
```




<b>Zwischenspeichern von Seiten mit Abfrageparametern/Argumenten</b>

<b>Hinweis:</b>

Eines der normalen Verhaltensweisen der [!DNL Dispatcher] -Modul ist, dass wenn eine Anfrage einen Abfrageparameter im URI hat (normalerweise angezeigt wie `/content/page.html?myquery=value`) wird das Zwischenspeichern der Datei übersprungen und direkt zur AEM Instanz geleitet. Sie erwägt, dass diese Anfrage eine dynamische Seite ist und nicht zwischengespeichert werden sollte. Dies kann Auswirkungen auf die Cache-Effizienz haben.

Wenn Sie Seiten in AEM haben, nehmen Sie `GET` Argumente/Abfrageparameter in der Adresszeile, die die Seitenfunktion unterstützen, aber keine unterschiedlichen HTML-Seiten rendern, sind gute Kandidaten für dieses Konfigurationselement. Sie können [!DNL dispatcher] welche Argumente ignoriert werden sollen und die Seite dennoch zwischenspeichern.
Beispiel: jemand hat einen Deep-Link-Referenzmechanismus für soziale Medien erstellt, der die Argumentreferenz im URI verwendet, um zu erfahren, woher die Person stammt.

<b>Beispiel:</b>

[https://www.retail.com/home.html?reference=android](https://www.retail.com/home.html?reference=android)

[https://www.retail.com/home.html?reference=facebook](https://www.retail.com/home.html?reference=facebook)

Die Seite kann zu 100 % zwischengespeichert werden, jedoch nicht zwischengespeichert werden, da die Argumente vorhanden sind. 
Um dies zu umgehen, fügen wir den folgenden Abschnitt zu unserer Farm-Konfigurationsdatei hinzu:


```
/cache { 
    /ignoreUrlParams { 
        /0001 { /glob "*" /type "deny" } 
        /0002 { /glob "reference" /type "allow" } 
    }
```


Jetzt, wenn die [!DNL dispatcher] sieht die Anfrage. Dadurch wird ignoriert, dass die Anfrage den Abfrageparameter ?reference aufweist und die Seite dennoch zwischenspeichert.



<b>Zwischenspeichern von Antwortheadern</b>

Es ist ziemlich offensichtlich, dass die [!DNL dispatcher] Caches `.html` Seiten und Client-Bibliotheken, wussten Sie jedoch, dass sie auch bestimmte Antwort-Header neben dem Inhalt in einer Datei mit demselben Namen, aber einer `.h` Dateierweiterung. Dadurch kann die nächste Antwort nicht nur auf den Inhalt, sondern auch auf die Antwortheader angewendet werden, die aus dem Cache gesendet werden sollen.

AEM kann mehr als nur UTF-8-Kodierung verarbeiten

Manchmal verfügen Elemente über spezielle Header, mit denen die Codierungsdetails der TTL-Cache-Datei und die zuletzt geänderten Zeitstempel gesteuert werden können.

Diese Werte beim Zwischenspeichern werden standardmäßig entfernt und die [!DNL apache] Der HTTPD-Webserver übernimmt die Verarbeitung des Assets mit seinen normalen Dateibearbeitungsmethoden, die normalerweise auf MIME-Typen beschränkt sind, die auf Dateierweiterungen basieren.

Wenn Sie [!DNL dispatcher] das Asset und die gewünschten Kopfzeilen zwischenspeichern, können Sie das richtige Erlebnis bereitstellen und sicherstellen, dass alle Details es dem Client-Browser bereitstellen.

Im Folgenden finden Sie ein Beispiel für eine Farm mit den Headern, die zwischengespeichert werden sollen:


```
/cache { 
 /headers { 
  "Cache-Control" 
  "Content-Disposition" 
  "Content-Type" 
  "Expires" 
  "Last-Modified" 
  "X-Content-Type-Options" 
 } 
}
```


In dem Beispiel, für das sie AEM zum Bereitstellen von Headern konfiguriert haben, prüft das CDN, wann der Cache invalidiert werden soll. Das bedeutet nun, AEM kann ordnungsgemäß bestimmen, welche Dateien basierend auf Headern invalidiert werden.

<b>Hinweis:</b>

Beachten Sie, dass Sie keine regulären Ausdrücke oder glob-Übereinstimmungen verwenden können. Es handelt sich um eine wörtliche Liste der Header, die zwischengespeichert werden sollen. Fügen Sie nur eine Liste der literalen Header ein, die zwischengespeichert werden sollen.



<b>Übergangsphase für automatische Invalidierung</b>

Auf AEM Systemen mit viel Aktivität von Autoren, die viele Seitenaktivierungen durchführen, kann es zu einer Race-Bedingung kommen, bei der wiederholte Invalidierungen auftreten. Erheblich wiederholte Leerungsanfragen sind nicht erforderlich und Sie können eine Toleranz aufbauen, um einen Leerlauf erst nach Ablauf der Übergangsphase zu wiederholen.

<b>Beispiel:</b>

Wenn Sie 5 Anforderungen zur Invalidierung haben `/content/exampleco/en/` alle treten innerhalb eines Zeitraums von 3 Sekunden auf.

Mit dieser Funktion würden Sie das Cache-Verzeichnis invalidieren `/content/exampleco/en/` 5-mal

Wenn diese Funktion aktiviert ist und auf 5 Sekunden festgelegt ist, wird das Cache-Verzeichnis invalidiert `/content/exampleco/en/` <b>once</b>

Hier finden Sie eine Beispielsyntax dieser Funktion, die für eine Übergangsphase von 5 Sekunden konfiguriert wird:


```
/cache { 
    /gracePeriod "5"
```




<b>TTL-basierte Invalidierung</b>

Eine neuere Funktion der [!DNL dispatcher] Modul war <b>Time to Live (TTL)</b> Optionen für die Invalidierung auf Basis der im Cache gespeicherten Elemente. Wenn ein Element zwischengespeichert wird, sucht es nach Cache-Steuerelement-Headern und generiert eine Datei im Cache-Verzeichnis mit demselben Namen und einer <b>`.ttl`</b> -Erweiterung.

Im Folgenden finden Sie ein Beispiel der Funktion, die in der Farm-Konfigurationsdatei konfiguriert wird:


```
/cache { 
    /enableTTL "1"
```


<b>Hinweis:</b>

Beachten Sie, dass AEM weiterhin so konfiguriert werden muss, dass TTL-Header für [!DNL dispatcher] um sie zu ehren. Durch das Umschalten dieser Funktion wird nur die [!DNL dispatcher] , um zu erfahren, wann die Dateien entfernt werden sollen, für die AEM Cache-Steuerelement-Header gesendet hat. Wenn AEM nicht beginnt, TTL-Header zu senden, dann [!DNL dispatcher] wird hier nichts Besonderes tun.



<b>Cache-Filterregeln</b>

Im Folgenden finden Sie ein Beispiel für eine Basiskonfiguration, für die Elemente in einem Publisher zwischengespeichert werden sollen:


```
/cache{ 
    /0000 { 
        /glob "*" 
        /type "allow" 
    } 
    /0001 { 
        /glob "/libs/granite/csrf/token.json" 
        /type "deny" 
    }
```


Wir möchten unsere veröffentlichte Site so gierig wie möglich machen und alles zwischenspeichern.

Wenn es Elemente gibt, die das Erlebnis beim Zwischenspeichern beschädigen, können Sie Regeln hinzufügen, um die Option zum Zwischenspeichern dieses Elements zu entfernen. Wie Sie im obigen Beispiel sehen, sollten die CSRF-Token nie zwischengespeichert und ausgeschlossen werden. Weitere Informationen zum Schreiben dieser Regeln finden Sie unter [here](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)
