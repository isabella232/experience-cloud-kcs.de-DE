---
title: "Analysieren von Speicherproblemen"
description: Beschreibung
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: "10/21/2021 5:18:56 PM"
article-published-by: Roxann McGlumphy
article-published-date: "10/21/2021 5:21:24 PM"
version-number: 1
article-number: KA-17482
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ef6bccf5-9232-ec11-b6e5-000d3a5ba97a"
exl-id: 48e49bcc-3d49-464e-8af9-e4292b1d6899
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '888'
ht-degree: 1%

---

# Analysieren von Speicherproblemen

## Beschreibung

<br>Symptome<br><br>
Die Java-Anwendung wird langsamer ausgeführt und schließlich ist der Speicher nicht mehr verfügbar, oder in den Protokollen oder in der Konsolenausgabe wird ein Fehler angezeigt `OutOfMemoryError: Java heap space` oder `OutOfMemoryError: gc overhead limit exceeded`.
<br><br>Ursache<br><br>
Solche Probleme können viele Ursachen haben.

Eine mögliche Ursache ist, dass die Java-Anwendung, in unserem Fall CRX / CQ von der Befehlszeile mit den standardmäßigen Heap-Speichereinstellungen von Java gestartet wurde. Das bedeutet, dass der jvm-Parameter `-Xmx` wurde nicht angegeben. CRX oder CQ benötigt mindestens 256 MB Heap, der für die Ausführung zugewiesen ist. Wenn dies das Problem ist, stellen Sie ab der Befehlszeile sicher, dass die Heap-Speichereinstellungen festgelegt sind. Beispiel:


```
java -Xmx512m -jar *.jar
```


Ist dies nicht der Fall, kann Ihre Anwendung zu viele Objekte beibehalten, ohne sie für die Speicherbereinigung freizugeben. Dies wird als Speicherleck bezeichnet, siehe [here](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html) für weitere Informationen. Informationen zur Analyse von Speicherproblemen in Java-Anwendungen finden Sie im folgenden Abschnitt.


## Auflösung

Heap-Dump erstellen<br><br>Generieren eines Heap-Dump automatisch<br><br>
Um automatisch ein Heap-Dump zu erstellen, wenn nicht genügend Arbeitsspeicher zur Verfügung steht, können Sie den Parameter jvm hinzufügen `-XX:+HeapDumpOnOutOfMemoryError` , um automatisch einen Heap-Dump zu generieren, wenn das Programm einen OutOfMemoryError ausgibt. Beispiel,


```
java -Xmx256m -XX:+HeapDumpOnOutOfMemoryError -jar *.jar
```


Dadurch wird eine Heap-Dump-Datei (`java_...hprof`) im Arbeitsverzeichnis des Prozesses, sobald der Java-Prozess nicht genügend Arbeitsspeicher hat. Der Prozess kann nach der Erstellung des Heap-Dumps weiter ausgeführt werden. Normalerweise reicht eine Heap-Dump-Datei aus, um das Problem zu analysieren.

<b>Hinweis:</b> wenn Sie `crx-quickstart/server/start` Skript, um Ihre CRX-Instanz zu starten, dann können Sie `-XX:+HeapDumpOnOutOfMemoryError` der `CQ_JVM_OPTS` (stellen Sie sicher, dass die Variable auch nicht kommentiert ist). Beispiel:


```
CQ_JVM_OPTS='-XX:+HeapDumpOnOutOfMemoryError'
```


Nachdem Sie diesen Parameter hinzugefügt und die CRX-Instanz neu gestartet haben, überprüfen Sie, ob die neue JVM-Option festgelegt ist. Ausführen `ps -ef | grep java` über die Befehlszeile. Überprüfen Sie dann, ob `-XX:+HeapDumpOnOutOfMemoryError` als Parameter des CRX-Java-Prozesses.

Wenn Sie ein anderes Verzeichnis angeben müssen, in dem der Heap-Dump aufgrund von Speicherplatzbeschränkungen generiert werden soll, können Sie die `-XX:HeapDumpPath=/path/to/generate/heapdump` -Parameter, um der jvm anzugeben, wo die Datei abgelegt werden soll.

Siehe [here](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions) für eine Referenz zum Debugging verwandter jvm-Parameter.
<br><br>Manuelles Generieren eines Heap-Dump<br><br>
<b>Sun/Oracle JVM</b>

Um manuell einen Heap-Dump zu generieren, führen Sie diesen Befehl aus (jmap und jps finden Sie im Abschnitt `bin` Ordner Ihres jdk-Basisverzeichnisses):

1. Suchen Sie nach der PID des Java-Prozesses, für den Sie eine Heap-Dump generieren.
   - In Unix oder Linux kann dies mit `ps -ef | grep java` oder `jps -l`
   - Unter Windows kann dies durch Öffnen des Aufgabenmanagers erfolgen, indem Sie die Taste drücken `Ctrl+Shift+Esc` Gehen Sie dann zu <b>Ansicht</b> = <b>Spalten auswählen</b> = <b>PID (Process Identifier)</b> oder `jps -l`
2. Führen Sie den Befehl jmap unten aus, ersetzen Sie `/path/to/generate/heapdumpfile.hprof` durch den Speicherort, an dem Sie die Heap-Dump-Datei generieren möchten, und ersetzen Sie `1234` mit der PID, die Sie im vorherigen Schritt nachgeschlagen haben.

   ```
   jmap -dump:format=b,file=/path/to/generate/heapdumpfile.hprof 1234
   ```


<b>IBM JVM</b>

Sie müssen zunächst die standardmäßigen JVM-Einstellungen für die Dump-Agenten ändern, um die richtigen Dumps für das Benutzersignal zu generieren. Es gibt mehrere Arten von Dumps, aber im Allgemeinen benötigen Sie die vollständige <b>Systemdump</b> , um eine gründliche Speicheranalyse durchzuführen. Fügen Sie die folgenden Argumente hinzu:

<b>Xdump:heap:opts=PHD+CLASSIC:events=user -Xdump:system:events=user</b>

Dieses &quot;Benutzer&quot;-Ereignis tritt auf, wenn die JVM das SIGQUIT-Signal (Linux, AIX®, z/OS® und i5/OS™) oder das SIGBREAK-Signal (Windows) vom Betriebssystem erhält.

Weitere Informationen finden Sie in der Dokumentation des Anbieters . [here](http://pic.dhe.ibm.com/infocenter/java7sdk/v7r0/index.jsp?topic=%2Fcom.ibm.java.aix.70.doc%2Fdiag%2Fpreface%2Fchanges_70%2Foverview_gc.html).

<b>Warnung:</b> Heap-Dump-Dateien sind groß und können auf der Festplatte dieselbe Größe aufweisen wie Ihre maximale Heap -Xmx jvm-Parameterkonfiguration. Vergewissern Sie sich, dass dem Ordner, in dem die Dump-Datei generiert wird, genügend Speicherplatz zugewiesen ist.
<br><br>Heap-Dump analysieren<br><br>
Ein gutes Tool zur Analyse von Heap-Dumps ist EclipseMAT (Eclipse Memory Analyzer): [http://www.eclipse.org/mat/](http://www.eclipse.org/mat/)

Dieses Tool kann nicht analysieren <b>IBM JVM</b> generierte Dumps. Für diese gibt es mehrere Möglichkeiten. [IBM HeapAnalyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=4544bafe-c7a2-455f-9d43-eb866ea60091) eignet sich gut für Heap-Dumps im PHD- oder klassischen Format.

Verwenden Sie für eine vollständige Analyse des System-Dump den [IBM Support Assistant Workbench](http://www-01.ibm.com/software/support/isa/) , mit [IBM Monitoring and Diagnostics Tools for Java - Memory Analyzer Version 1.2](http://www.ibm.com/developerworks/java/jdk/tools/memoryanalyzer/) oben installiert.
<br><br>Heap-Histogramm<br><br>
Das Heap-Histogramm ist eine einfache Messung der Anzahl der Live-Objekte und des Speichers, die pro Java-Klasse verwendet werden. Je nach Java-Installation sind die erforderlichen Tools leider nicht verfügbar oder funktionieren möglicherweise nicht immer. Um ein Heap-Histogramm zu erstellen, benötigen Sie zunächst die Prozess-ID des Java-Prozesses. Um es zu erhalten, führen Sie `ps` oder (falls verfügbar) ausführen:


```
jps -l
```


Dieses Java-Tool ruft die Prozess-IDs aller ausgeführten Java-Prozesse ab. Beispiel:


```
327 
3332 sun.tools.jps.Jps
3313 crx-quickstart-....jar
```


Führen Sie nun den folgenden Befehl aus:


```
jmap -histo 3313
```


Die Liste ist nach dem erforderlichen Gesamtspeicherbedarf sortiert (flach: referenzierte Objekte ausschließen). Die ersten 20 Zeilen der Ausgabe sind die interessantesten. Beispielausgabe:


```
JVM version is 1.5.0_20-141
Iterating over heap. This may take a while...
Warning: skipping invalid TLAB for thread t@62211
Warning: skipping invalid TLAB for thread t@62467
...
SizeCountClass description
-------------------------------------------------------
1059290412916byte
1028584075255* ConstMethodKlass
628317658388char
604230414928int
4995752116201* SymbolKlass
422089675255* MethodKlass
41965126969* ConstantPoolKlass
29285606969* InstanceKlassKlass
26310086066* ConstantPoolCacheKlass
2395872149742org.apache.jackrabbit.core.query.lucene.DocId$PlainDocId
14760087003java.util.HashMap$Entry
139612858172java.lang.String
107023244593java.util.HashMap$Entry
75398410036short
73546454org.apache.jackrabbit.core.query.lucene.DocId
7201927502java.lang.Class
64070413348com.day.crx.persistence.tar.index.IndexEntry
...
```


<b>Weitere Informationen</b>

Um das Problem analysieren zu können, müssen wir auch die folgenden Informationen kennen:

- CRX- oder CQ-Version, einschließlich einer Liste aller installierten Hotfixes-Versionsnummern.
- Betriebssystem, JVM-Anbieter und Version.


<b>Verweise</b>

1 [http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)
2 [http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)
