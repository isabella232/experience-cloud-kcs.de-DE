---
title: "Analysieren von Speicherproblemen"
description: Beschreibung
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: "10/21/2021 5:18:56 PM"
article-published-by: Roxann McGlumphy
article-published-date: "10/21/2021 5:21:24 PM"
version-number: 1
article-number: KA-17482
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ef6bccf5-9232-ec11-b6e5-000d3a5ba97a"
exl-id: 48e49bcc-3d49-464e-8af9-e4292b1d6899
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: tm+mt
source-wordcount: '866'
ht-degree: 1%

---

# Analysieren von Speicherproblemen

## Beschreibung

<br>Symptome<br><br>
Die [!DNL Java] Die Anwendung läuft langsamer und läuft schließlich nicht mehr genügend Speicher, oder in den Protokollen oder in der Konsolenausgabe tritt ein Fehler auf `OutOfMemoryError: Java heap space` oder `OutOfMemoryError: gc overhead limit exceeded`.
<br><br>Ursache<br><br>
Solche Probleme können viele Ursachen haben.

Eine mögliche Ursache ist, dass [!DNL Java] -Anwendung, in unserem Fall wurde CRX/CQ von der Befehlszeile mit den standardmäßigen Heap-Speichereinstellungen von [!DNL Java]. Das bedeutet, dass der jvm-Parameter `-Xmx` wurde nicht angegeben. CRX oder CQ benötigt mindestens 256 MB Heap, der für die Ausführung zugewiesen ist. Wenn dies das Problem ist, stellen Sie ab der Befehlszeile sicher, dass die Heap-Speichereinstellungen festgelegt sind. Beispiel:


```
java -Xmx512m -jar *.jar
```


Ist dies nicht der Fall, kann Ihre Anwendung zu viele Objekte beibehalten, ohne sie für die Speicherbereinigung freizugeben. Dies wird als Speicherleck bezeichnet, siehe [here](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html) für weitere Informationen. Informationen zur Analyse von Speicherproblemen in Java-Anwendungen finden Sie im folgenden Abschnitt.


## Auflösung

Heap-Dump erstellen<br><br>Generieren eines Heap-Dump automatisch<br><br>
Um automatisch ein Heap-Dump zu erstellen, wenn nicht genügend Arbeitsspeicher zur Verfügung steht, können Sie den Parameter jvm hinzufügen `-XX:+HeapDumpOnOutOfMemoryError` , um automatisch einen Heap-Dump zu generieren, wenn die Anwendung ein `OutOfMemoryError`. Beispiel,


```
java -Xmx256m -XX:+HeapDumpOnOutOfMemoryError -jar *.jar
```


Dadurch wird eine Heap-Dump-Datei (`java_...hprof`) im Arbeitsverzeichnis des Prozesses immer dann, wenn die `java` Der Arbeitsspeicher ist knapp. Der Prozess kann nach der Erstellung des Heap-Dumps weiter ausgeführt werden. Normalerweise reicht eine Heap-Dump-Datei aus, um das Problem zu analysieren.

<b>Hinweis:</b> wenn Sie `crx-quickstart/server/start` Skript, um Ihre CRX-Instanz zu starten, dann können Sie `-XX:+HeapDumpOnOutOfMemoryError` der `CQ_JVM_OPTS` (stellen Sie sicher, dass die Variable auch nicht kommentiert ist). Beispiel:


```
CQ_JVM_OPTS='-XX:+HeapDumpOnOutOfMemoryError'
```


Nachdem Sie diesen Parameter hinzugefügt und die CRX-Instanz neu gestartet haben, überprüfen Sie, ob die neue JVM-Option festgelegt ist. Ausführen `ps -ef | grep java` über die Befehlszeile. Überprüfen Sie dann, ob `-XX:+HeapDumpOnOutOfMemoryError` als Parameter des CRX `java` Prozess.

Wenn Sie ein anderes Verzeichnis angeben müssen, in dem der Heap-Dump aufgrund von Speicherplatzbeschränkungen generiert werden soll, können Sie die `-XX:HeapDumpPath=/path/to/generate/heapdump` -Parameter, um der jvm anzugeben, wo die Datei abgelegt werden soll.

Siehe [here](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions) für eine Referenz zum Debugging verwandter jvm-Parameter.
<br><br>Manuelles Generieren eines Heap-Dump<br><br>
<b>[!DNL Sun]/Oracle JVM</b>

Um manuell einen Heap-Dump zu generieren, führen Sie diesen Befehl aus (jmap und jps finden Sie im Abschnitt `bin` Ordner Ihres jdk-Basisverzeichnisses):

1. Nachschlagen der PID des `java` -Prozess verwenden, für den Sie eine Heap-Sicherungskopie generieren.
   - In [!DNL Unix] oder [!DNL Linux] Dies kann mit `ps -ef | grep java` oder `jps -l`
   - In [!DNL Windows] Dies kann durch Öffnen des Aufgabenmanagers geschehen, drücken Sie `Ctrl+Shift+Esc` Gehen Sie dann zu <b>Ansicht</b> = <b>Spalten auswählen</b> = <b>PID (Process Identifier)</b> oder `jps -l`
2. Führen Sie den Befehl jmap unten aus, ersetzen Sie `/path/to/generate/heapdumpfile.hprof` durch den Speicherort, an dem Sie die Heap-Dump-Datei generieren möchten, und ersetzen Sie `1234` mit der PID, die Sie im vorherigen Schritt nachgeschlagen haben.

   ```
   jmap -dump:format=b,file=/path/to/generate/heapdumpfile.hprof 1234
   ```


<b>IBM JVM</b>

Sie müssen zunächst die standardmäßigen JVM-Einstellungen für die Dump-Agenten ändern, um die richtigen Dumps für das Benutzersignal zu generieren. Es gibt mehrere Arten von Dumps, aber im Allgemeinen benötigen Sie die vollständige <b>Systemdump</b> , um eine gründliche Speicheranalyse durchzuführen. Fügen Sie die folgenden Argumente hinzu:

<b>Xdump:heap:opts=PHD+CLASSIC:events=user -Xdump:system:events=user</b>

Dieses &quot;Benutzer&quot;-Ereignis tritt auf, wenn die JVM das SIGQUIT ([!DNL Linux], AIX®, z/OS® und i5/OS™) oder SIGBREAK ([!DNL Windows]) Signal vom Betriebssystem aus.

Weitere Informationen finden Sie in der Dokumentation des Anbieters . [here](http://pic.dhe.ibm.com/infocenter/java7sdk/v7r0/index.jsp?topic=%2Fcom.ibm.java.aix.70.doc%2Fdiag%2Fpreface%2Fchanges_70%2Foverview_gc.html).

<b>Warnung:</b> Heap-Dump-Dateien sind groß und können auf der Festplatte dieselbe Größe aufweisen wie Ihr maximaler Heap `-Xmx` jvm-Parameterkonfiguration. Vergewissern Sie sich, dass dem Ordner, in dem die Dump-Datei generiert wird, genügend Speicherplatz zugewiesen ist.
<br><br>Heap-Dump analysieren<br><br>
Ein gutes Tool zur Analyse von Heap-Dumps ist [!DNL Eclipse] MAT ([!DNL Eclipse Memory Analyzer]): [http://www.eclipse.org/mat/](http://www.eclipse.org/mat/)

Dieses Tool kann nicht analysieren <b>IBM JVM</b> generierte Dumps. Für diese gibt es mehrere Möglichkeiten. [IBM HeapAnalyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=4544bafe-c7a2-455f-9d43-eb866ea60091) eignet sich gut für Heap-Dumps im PHD- oder klassischen Format.

Verwenden Sie für eine vollständige Analyse des System-Dump den [IBM Support Assistant Workbench](http://www-01.ibm.com/software/support/isa/) , mit [IBM Monitoring and Diagnostics Tools for Java - Memory Analyzer Version 1.2](http://www.ibm.com/developerworks/java/jdk/tools/memoryanalyzer/) oben installiert.
<br><br>Heap-Histogramm<br><br>
Das Heap-Histogramm ist eine einfache Messung der Anzahl von Live-Objekten und des Speichers, die pro [!DNL Java] -Klasse. Je nach [!DNL Java] installiert ist, sind die erforderlichen Tools möglicherweise nicht verfügbar oder funktionieren nicht immer. Um ein Heap-Histogramm zu erstellen, benötigen Sie zunächst die Prozess-ID des [!DNL Java] Prozess. Um es zu erhalten, führen Sie `ps` oder (falls verfügbar) ausführen:


```
jps -l
```


Diese [!DNL Java] -Tool ruft die Prozess-IDs aller ausgeführten [!DNL Java] Prozesse. Beispiel:


```
327 
3332 sun.tools.jps.Jps
3313 crx-quickstart-....jar
```


Führen Sie nun den folgenden Befehl aus:


```
jmap -histo 3313
```


Die Liste ist nach dem erforderlichen Gesamtspeicherbedarf sortiert (flach: referenzierte Objekte ausschließen). Die ersten 20 Zeilen der Ausgabe sind die interessantesten. Beispielausgabe:


```
JVM version is 1.5.0_20-141
Iterating over heap. This may take a while...
Warning: skipping invalid TLAB for thread t@62211
Warning: skipping invalid TLAB for thread t@62467
...
SizeCountClass description
-------------------------------------------------------
1059290412916byte
1028584075255* ConstMethodKlass
628317658388char
604230414928int
4995752116201* SymbolKlass
422089675255* MethodKlass
41965126969* ConstantPoolKlass
29285606969* InstanceKlassKlass
26310086066* ConstantPoolCacheKlass
2395872149742org.apache.jackrabbit.core.query.lucene.DocId$PlainDocId
14760087003java.util.HashMap$Entry
139612858172java.lang.String
107023244593java.util.HashMap$Entry
75398410036short
73546454org.apache.jackrabbit.core.query.lucene.DocId
7201927502java.lang.Class
64070413348com.day.crx.persistence.tar.index.IndexEntry
...
```


<b>Weitere Informationen</b>

Um das Problem analysieren zu können, müssen wir auch die folgenden Informationen kennen:

- CRX- oder CQ-Version, einschließlich einer Liste aller installierten Hotfixes-Versionsnummern.
- Betriebssystem, JVM-Anbieter und Version.


<b>Verweise</b>

1 [http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)
2 [http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)
