---
title: „Analysieren von Speicherproblemen“
description: Beschreibung
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: „KCS“
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: "10/21/2021 5:18:56 PM"
article-published-by: Roxann McGlumphy
article-published-date: "10/21/2021 5:21:24 PM"
version-number: 1
article-number: KA-17482
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ef6bccf5-9232-ec11-b6e5-000d3a5ba97a"
exl-id: 48e49bcc-3d49-464e-8af9-e4292b1d6899
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: tm+mt
source-wordcount: '866'
ht-degree: 100%

---

# Analysieren von Speicherproblemen

## Beschreibung

<br>Symptome<br><br>
Die [!DNL Java]-Anwendung läuft langsamer und schließlich geht ihr der Speicher aus oder Sie sehen einen Fehler in den Protokollen oder in der Konsolenausgabe `OutOfMemoryError: Java heap space` oder `OutOfMemoryError: gc overhead limit exceeded`.
<br><br>Ursache<br><br>
Solche Probleme können viele Ursachen haben.

Eine mögliche Ursache ist, dass die [!DNL Java]-Anwendung, in unserem Fall CRX / CQ, von der Befehlszeile mit den Standard-Heap-Speichereinstellungen von [!DNL Java] gestartet wurde. Das bedeutet, dass der jvm-Parameter `-Xmx` nicht angegeben wurde. CRX oder CQ benötigt mindestens 256 MB Heap, der für die Ausführung zugewiesen ist. Wenn dies das Problem ist, stellen Sie über die Befehlszeile sicher, dass die Heap-Speichereinstellungen festgelegt sind. Beispiel:


```
java -Xmx512m -jar *.jar
```


Ist dies nicht der Fall, kann Ihre Anwendung zu viele Objekte beibehalten, ohne sie für die Speicherbereinigung freizugeben. Dies wird als Speicherleck bezeichnet, weitere Informationen finden Sie [hier](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html). Informationen zur Analyse von Speicherproblemen in Java-Anwendungen finden Sie im folgenden Abschnitt.


## Lösung

Erstellen eines Heap-Dump<br><br>Automatisches Generieren eines Heap-Dump<br><br>
Um automatisch einen Heap-Dump zu erstellen, wenn nicht genügend Arbeitsspeicher zur Verfügung steht, können Sie den jvm-Parameter `-XX:+HeapDumpOnOutOfMemoryError` hinzufügen, um automatisch einen Heap-Dump zu generieren, wenn die Anwendung einen `OutOfMemoryError` ausgibt. So wird beispielsweise


```
java -Xmx256m -XX:+HeapDumpOnOutOfMemoryError -jar *.jar
```


eine Heap-Dump-Datei (`java_...hprof`) im Arbeitsverzeichnis des Prozesses erzeugt, wenn dem `java`-Prozess der Speicher ausgeht. Der Prozess kann nach der Erstellung des Heap-Dumps weiter ausgeführt werden. Normalerweise reicht eine Heap-Dump-Datei aus, um das Problem zu analysieren.

<b>Hinweis:</b> Wenn Sie das `crx-quickstart/server/start`-Skript zum Starten Ihrer CRX-Instanz verwenden, können Sie `-XX:+HeapDumpOnOutOfMemoryError` zur Variable `CQ_JVM_OPTS` hinzufügen (stellen Sie sicher, dass die Variable auch unkommentiert ist). Beispiel:


```
CQ_JVM_OPTS='-XX:+HeapDumpOnOutOfMemoryError'
```


Nachdem Sie diesen Parameter hinzugefügt und die CRX-Instanz neu gestartet haben, überprüfen Sie, ob die neue jvm-Option festgelegt ist. Führen Sie `ps -ef | grep java` über die Befehlszeile aus. Überprüfen Sie dann, ob `-XX:+HeapDumpOnOutOfMemoryError` als Parameter des CRX-`java`-Prozess angezeigt wird.

Wenn Sie aufgrund von Speicherplatzbeschränkungen ein anderes Verzeichnis für den Heap-Dump angeben müssen, können Sie den Parameter `-XX:HeapDumpPath=/path/to/generate/heapdump` hinzufügen, um dem jvm mitzuteilen, wo die Datei abgelegt werden soll.

[Hier](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions) finden Sie eine Referenz für das Debugging von jvm-Parametern.
<br><br>Manuelles Generieren eines Heap-Dump<br><br>
<b>[!DNL Sun]/Oracle JVM</b>

Um manuell einen Heap-Dump zu erzeugen, führen Sie diesen Befehl aus (jmap und jps befinden sich im Ordner `bin` Ihres jdk-Basis-Verzeichnisses):

1. Schlagen Sie die PID des `java`-Prozesses nach, für den Sie einen Heap-Dump erzeugen.
   - In [!DNL Unix] oder [!DNL Linux] kann dies mit `ps -ef | grep java` oder `jps -l` geschehen.
   - In [!DNL Windows] kann dies durch Öffnen des Aufgabenmanagers geschehen, drücken Sie `Ctrl+Shift+Esc`, gehen Sie dann zu <b>Ansicht</b> > <b>Spalten auswählen</b> > <b>PID (Process-ID)</b> oder `jps -l`.
2. Führen Sie den untenstehenden jmap-Befehl unten aus, ersetzen Sie `/path/to/generate/heapdumpfile.hprof` durch den Speicherort, an dem Sie die Heap-Dump-Datei erzeugen möchten, und ersetzen Sie `1234` mit der PID, die Sie im vorherigen Schritt nachgeschlagen haben.

   ```
   jmap -dump:format=b,file=/path/to/generate/heapdumpfile.hprof 1234
   ```


<b>IBM JVM</b>

Sie müssen zunächst die standardmäßigen JVM-Einstellungen für die Dump-Agenten ändern, um die richtigen Dumps für das Benutzersignal zu erzeugen. Es gibt verschiedene Arten von Dumps, aber im Allgemeinen benötigen Sie einen vollständigen <b>System-Dump</b>, um eine gründliche Speicheranalyse durchzuführen. Fügen Sie die folgenden Argumente hinzu:

<b>Xdump:heap:opts=PHD+CLASSIC:events=user -Xdump:system:events=user</b>

Dieses „Benutzer“-Ereignis tritt ein, wenn das JVM das Signal SIGQUIT ([!DNL Linux], AIX®, z/OS® und i5/OS™) oder SIGBREAK ([!DNL Windows]) vom Betriebssystem erhält.

Weitere Informationen finden Sie in der Dokumentation des Anbieters [hier](http://pic.dhe.ibm.com/infocenter/java7sdk/v7r0/index.jsp?topic=%2Fcom.ibm.java.aix.70.doc%2Fdiag%2Fpreface%2Fchanges_70%2Foverview_gc.html).

<b>Warnung:</b> Heap-Dump-Dateien sind groß und können auf der Festplatte so groß sein wie die Konfiguration der maximalen Heap-`-Xmx`-JVM-Parameter. Vergewissern Sie sich, dass dem Ordner, in dem die Dump-Datei erzeugt wird, genügend Speicherplatz zugewiesen ist.
<br><br>Analyse des Heap-Dump<br><br>
Ein gutes Tool zur Analyse von Heap-Dumps ist [!DNL Eclipse] MAT ([!DNL Eclipse Memory Analyzer]): [http://www.eclipse.org/mat/](http://www.eclipse.org/mat/)

Dieses Tool kann keine mittels <b>IBM JVM</b> erzeugten Dumps analysieren. Für diese gibt es mehrere Möglichkeiten. [IBM HeapAnalyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=4544bafe-c7a2-455f-9d43-eb866ea60091) eignet sich gut für Heap-Dumps im PHD- oder klassischen Format.

Für eine vollständige System-Dump-Analyse verwenden Sie die [IBM Support Assistant Workbench](http://www-01.ibm.com/software/support/isa/), auf der zusätzlich [IBM Monitoring and Diagnostic Tools for Java – Memory Analyzer Version 1.2](http://www.ibm.com/developerworks/java/jdk/tools/memoryanalyzer/) installiert ist.
<br><br>Heap-Histogramm<br><br>
Das Heap-Histogramm ist ein einfaches Maß für die Anzahl der lebenden Objekte und des belegten Speichers pro [!DNL Java]-Klasse. Leider kann es sein, dass je nach Installation von [!DNL Java] die erforderlichen Tools nicht verfügbar sind oder nicht immer funktionieren. Um ein Heap-Histogramm zu erstellen, benötigen Sie zunächst die Prozess-ID des [!DNL Java]-Prozesses. Um diese zu erhalten, führen Sie `ps` oder (falls verfügbar) Folgendes aus:


```
jps -l
```


Dieses [!DNL Java]-Tool ruft die Prozess-IDs aller ausgeführten [!DNL Java]-Prozesse ab. Beispiel:


```
327 
3332 sun.tools.jps.Jps
3313 crx-quickstart-....jar
```


Führen Sie jetzt den folgenden Befehl aus:


```
jmap -histo 3313
```


Die Liste ist nach dem erforderlichen Gesamtspeicherbedarf sortiert (flach: referenzierte Objekte ausschließen). Die ersten 20 Zeilen der Ausgabe sind die interessantesten. Beispielausgabe:


```
JVM version is 1.5.0_20-141
Iterating over heap. This may take a while...
Warning: skipping invalid TLAB for thread t@62211
Warning: skipping invalid TLAB for thread t@62467
...
SizeCountClass description
-------------------------------------------------------
1059290412916byte
1028584075255* ConstMethodKlass
628317658388char
604230414928int
4995752116201* SymbolKlass
422089675255* MethodKlass
41965126969* ConstantPoolKlass
29285606969* InstanceKlassKlass
26310086066* ConstantPoolCacheKlass
2395872149742org.apache.jackrabbit.core.query.lucene.DocId$PlainDocId
14760087003java.util.HashMap$Entry
139612858172java.lang.String
107023244593java.util.HashMap$Entry
75398410036short
73546454org.apache.jackrabbit.core.query.lucene.DocId
7201927502java.lang.Class
64070413348com.day.crx.persistence.tar.index.IndexEntry
...
```


<b>Weitere Informationen</b>

Um das Problem analysieren zu können, müssen wir auch die folgenden Informationen kennen:

- CRX- oder CQ-Version, einschließlich einer Liste aller installierten Hotfixes-Versionsnummern.
- Betriebssystem, JVM-Anbieter und Version.


<b>Verweise</b>

1 [http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)
2 [http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)
