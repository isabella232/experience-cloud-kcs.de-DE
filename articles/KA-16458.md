---
title: "AEM Thread Dump Analysis"
description: Beschreibung
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: "Helpx Link: https://helpx.adobe.com/experience-manager/kb/thread-dump-analysis.html"
bug: false
article-created-by: Emily Geary
article-created-date: "3/17/2021 9:11:03 PM"
article-published-by: Emily Geary
article-published-date: "3/17/2021 9:13:37 PM"
version-number: 2
article-number: KA-16458
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e70a8345-6587-eb11-a812-000d3a593216"
exl-id: 74bb70e4-a09b-48fc-8378-96a1736e5ebf
source-git-commit: a59847e2e7e37f432cb01150b9444cd9dbf585df
workflow-type: tm+mt
source-wordcount: '1000'
ht-degree: 0%

---

# AEM Thread Dump Analysis

## Beschreibung

AEM analysieren [!DNL Java] Thread-Sicherheitskopien mit [IBM Thread Analyzer](http://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=2245aa39-fa5c-4475-b891-14c205f7333c) -Tool.

## Auflösung

1. Herunterladen und installieren [IBM Thread Analyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=2245aa39-fa5c-4475-b891-14c205f7333c) (nennen wir es kurz IBM TDA)
1. Capture [Thread-Sicherheitskopien](https://helpx.adobe.com/experience-manager/kb/TakeThreadDump.html) von einer AEM Instanz, bei der Leistungsprobleme auftreten.
1. Öffnen Sie die Thread-Sicherheitskopien in IBM TDA.
1. Um die Details eines Thread-Dump anzuzeigen, wählen Sie die Datei in der Liste aus und klicken Sie dann auf die Schaltfläche &quot;Thread Detail&quot;\*.

![tda-threaddetail](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1587732783/tda-threaddetail.png "tda-threaddetail")

1. Sortieren Sie nach &quot;Stapeltiefe&quot;mit den längsten Stapeln oben.

   ![tda-image1](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image/tda-image1.png)

1. Überprüfen Sie die Threads mit einer Stapeltiefe von 10 Zeilen oder mehr.  Dies sind normalerweise die Threads, die am meisten Interesse zeigen.  Nehmen Sie Hinweise zu interessanten Threads vor.
1. Sortieren nach Thread &quot;State&quot;
1. Scrollen Sie nach unten zu den &quot;Runnable&quot;-Threads. Runnable Threads sind diejenigen, die aktiv CPU-Zeit in Anspruch nahmen, als die Thread-Sicherheitskopie aufgenommen wurde.

   *Hinweis: Bei der Überprüfung der &quot;Ausführbaren&quot; Threads können Sie die Threads ignorieren, die in der [Threads, die ignoriert werden können](https://helpx.adobe.com/experience-manager/kb/thread-dump-analysis.html#ignorethreads) unten auf dieser Seite.*

1. Suchen Sie ausführbare Threads, die Teil der Anwendung sind, z. B. Hintergrund-Auftrags-Threads oder Anfrage-Threads (Anforderungs-Threads haben Namen wie diese *127.0.0.1 1347028187737 GET /content/sites/global/en/sitemap.static-delivery.httpd.html HTTP/1.1*). Sobald Sie sie gefunden haben, klicken Sie sie einzeln an.

1. Für jeden Anforderungs-Thread können Sie feststellen, wann der Browser des Benutzers die Anfrage an den Server gesendet hat, indem Sie den Zeitstempel im Thread-Namen überprüfen.  Im obigen Thread-Namen ist beispielsweise der Zeitstempel (im Unix-Epochenformat Millisekunde) 1347028187737.  Diese Epochenzahl kann mithilfe von [www.epochconverter.com](http://www.epochconverter.com/).  Jeder Thread-Dump zeigt das Datum und die Uhrzeit der Aufnahme an.  Sie können den Zeitunterschied zwischen der Anforderungszeit und der Thread-Dump-Zeit nehmen, um zu sehen, wie lange eine Anforderung aktiv war.

1. Scrollen Sie nach Überprüfung der Anfrage-Threads durch die anderen &quot;Ausführbaren&quot; Threads.  Sobald Sie einen &quot;Runnable&quot;-Thread gefunden haben, sehen Sie sich den mittleren Bereich &quot;Warten von Threads&quot;an.  Die dort aufgeführten Threads warten darauf, dass der ausgewählte Thread einen Monitor freigibt.  Wenn keine wartenden Threads angezeigt werden, kann Ihr ausgewählter Thread weiterhin Eigentümer eines [Sperren](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html) (siehe Implementieren von Klassen von [Sperren](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html) für Details). Beispiel: mit einer [ReentrantReadWriteLock](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html) Sie können nicht erkennen, welcher Thread der Sperrhalter ist, da Sperren mehrere Monitore intern implementieren.  So müssen Sie sich vielleicht den Quellcode ansehen, um ihn mit einem Thread abzugleichen, der der Sperrhalter sein könnte.

1. Wenn der Thread über eine Sperrung oder einen Monitor verfügte, auf die viele andere Threads warteten, gehen Sie durch den Rest der Thread-Sicherheitskopien, um zu sehen, ob Sie andere Threads finden können, die dasselbe Problem haben.  Überprüfen Sie, ob der gleiche Thread noch in den anderen Dumps vorhanden ist (in IBM TDA können Sie mehrere Thread-Sicherheitskopien auswählen und auf die Schaltfläche &quot;Threads vergleichen&quot;\* klicken, um den Status eines Threads über mehrere Thread-Sicherheitskopien hinweg anzuzeigen.

   ![tda-comparethreads](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1159496390/tda-comparethreads.png)

1. Siehe Collector Service im folgenden Screenshot:

   ![tda-Image2](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1730877898/tda-Image2.png)

1. In dieser Ansicht können Sie den Thread über mehrere Thread-Sicherheitskopien hinweg sehen, um zu sehen, ob es sich um einen langwierigen Thread handelt.  Wenn der Thread sich in mehreren Dumps im Status &quot;Wird ausgeführt&quot;befindet und einen langen Stapel hat, bedeutet dies normalerweise, dass es sich um einen langwierigen Thread handelt.

1. Wenn Sie sich die laufenden Threads nicht genau angeschaut haben und dann zur Thread-Liste zurückkehren, wählen Sie einen Thread-Dump aus und klicken Sie dann im oberen Bereich auf die Schaltfläche &quot;Detail überwachen&quot;\*. IBM TDA öffnet ein Fenster mit einer Baumstrukturansicht der Überwachungs-Threads und ihrer Wartethreads. Hinweis: Möglicherweise werden einige Thread-Pool-Threads wie der Thread-Poolmonitor der Servlet-Engine angezeigt, während inaktive Threads ignoriert werden könnten.  Normalerweise können Sie erkennen, dass ein Thread ein inaktiver Thread-Pool-Thread ist, da er meist nur 10 Stacklinien oder weniger hat.

![tda-monitoring-etail](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1106466084/tda-monitordetail.png)

<b>CPU-Auslastung auf Thread-Ebene ([!DNL Linux] nur Plattform):</b>

1. Wenn Sie zusätzlich zu den Thread-Sicherheitskopien die Ausgabe &quot;top -H -b -n1 -p javapid&quot;erfasst haben, können Sie die CPU-Auslastung auf Thread-Ebene Querverweise erstellen.  Öffnen Sie die obere Ausgabe und rufen Sie die Prozess-ID der Threads ab, die die CPU verwenden.  Konvertieren Sie die Prozess-ID in einen Hexadezimalwert und suchen Sie dann in der entsprechenden Thread-Dump-Datei nach diesem Hexadezimalwert.  Die ID sollte mit der &quot;nid&quot;eines der Threads übereinstimmen.
1. Wenn der passende Thread, der die meisten CPU verwendet, die &quot;VM Thread&quot; oder &quot;GC&quot; Threads ist, kann es zu einem Speicherproblem kommen.  Wiederholen Sie dieselbe Übung für weitere Thread-Dumps und die Top-Ausgabe. Wenn ein Muster dieser Threads CPU-Zeit in Anspruch nimmt, liegt ein Speicherproblem vor.
1. Wenn Sie das Speicherproblem bestätigt haben, erfassen Sie beim nächsten Auftreten des Problems einen Heap-Dump.  Siehe [diesem Artikel](https://helpx.adobe.com/experience-manager/kb/AnalyzeMemoryProblems.html) Weitere Informationen zum Erfassen und Analysieren von Heap-Dumps.

![](https://helpx.adobe.com/libs/cq/ui/resources/0.gif)![](https://helpx.adobe.com/libs/cq/ui/resources/0.gif)

Threads, die ignoriert werden können:

- VM Thread: Dies ist ein VM-System-Thread.
- Threads, die mit dem GC-Task-Thread beginnen: Dies sind Speicherbereinigungs-Threads.
- Threads mit ähnlichen Namen wie - 1347028691218 im Code unter java.net.PlainSocketImpl.socketAccept(Native Method): Dies sind Threads aus dem Thread-Pool der Servlet-Engine, die auf neue Verbindungen warten.
